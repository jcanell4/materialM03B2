<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
     <meta name="author" content="Alícia Vila" >    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Activitat d'aprenentatge per introduir els conceptes de classe, biblioteques i tipus composts">
    
    
    <title>A501. Classes i biblioteques</title>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap.min.css" type="text/css"/>
<!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">-->
    <link rel="stylesheet" href="js/styles/default.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!-- Custom CSS -->
    <!--link to css slides-->
    <link href="css/m03b2Activities.css" rel="stylesheet">
    <link href="css/scrolling-slides.css" rel="stylesheet">
    <link href="css/highlightActivities.css" rel="stylesheet">
</head>
<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top">
 <span id="svgContainerId">
     <svg id="svgId" width="0" height="0" >
         <path id="pathId" d="M0 0" fill="none" stroke-width="8px"/>    
    </svg>
</span> 
<!-- Navigation hidden panel -->
    <aside>
        <a id="menu-toggle" href="#" class="btn btn-dark toggle after-top-menu" title="Informació"><i class="glyphicon glyphicon-info-sign"></i></a>
        <nav id="sidebar-wrapper" class=" after-top-menu">           
            <ul class="sidebar-nav">
                <a id="menu-close" href="#" class="btn btn-light pull-right toggle">
                    <i class="glyphicon glyphicon-remove-circle"></i>
                </a>
                <li class="sidebar-brand">
                    <a href="#slc-toStart"  onclick = '$("#menu-close").click();' >Inici activitat</a>
                </li>
                <li>
                    <a href="#" onclick = 'return $("#goals_info").togglePanelOnClick();'>Objectius</a>
                </li>
                <li> 
                    <a class="toActivityTable targetBlank" onclick = '$("#menu-close").click();'>Taula d'activitats</a>
                </li>
                <li>
                    <a class="toProjectStatement" onclick = '$("#menu-close").click();' >Enunciat del projecte</a>
                </li>
                <li>
                    <a href="#" onclick ='return $("#more_reinforcement").togglePanelOnClick(); '>Per reforçar</a>
                </li>
                <li>
                    <a href="#" onclick ='return $("#more_info").togglePanelOnClick(); '>Més informació per ampliar</a>
                </li>
            </ul>
        </nav>
        <nav id="bottom-wrapper">
             <!-- SCROLL PREVIOUS BUTTON -->
            <span id="prevArrow" class="btn arrownav previousSection" ></span>
            <!-- END SCROLL TOP BUTTON -->
             <!-- SCROLL NEXT BUTTON -->
            <span id="nextArrow" class="btn arrownav nextSection" ></span>
            <!-- END SCROLL TOP BUTTON -->
        </nav>        
    </aside>
    <!--=========== BEGIN HEADER SECTION ================-->
     <header id="header">
         <!-- BEGIN MENU -->
        <div class="menu_area">
            <nav class="navbar navbar-default navbar-fixed-top" role="navigation"> 
                <!-- LOGO -->
                <span class="navbar-brand navbar-left logo-nav"><img src="images/logo.png" title="{{$LOGO_TITLE}}" /></span>
                <div class="container-fluid">
                    <div class="navbar-header">
                    <!-- FOR MOBILE VIEW COLLAPSED BUTTON -->
                        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                          <span class="sr-only">Menú</span>
                          <span class="icon-bar"></span>
                          <span class="icon-bar"></span>
                          <span class="icon-bar"></span>
                        </button>
                    </div>
                    <div id="navbar" class="navbar-collapse collapse">
                        <ul id="top-menu" class="nav navbar-nav navbar-right main_nav">
                          <li class="active"><a href="#slc-toStart">Inici</a></li>
                          <li><a href="#slc-toKnow">Què cal saber</a></li> 
                          <li><a href="#slc-toDo">Què cal fer</a></li>
                          <li><a href="#slc-toDelivery">Lliurament</a></li> 
                          <li><a href="#slc-toContinue">Com continuar</a></li> 
                        </ul>           
                    </div>
                </div>     
            </nav>  
        </div>
        <!-- END MENU -->
    </header>
    <!--=========== END HEADER SECTION ================-->
    
    <!--=========== BEGIN MAIN SLIDER SECTION ================-->    
    <div id="mainSlider" class="iocMainPanel">
        <div class="slides">
            <!--=========== BEGIN SECTION toStart ================-->    
            <section id="slc-toStart" class="section">
                <div class="container">  <!--Bootstrap container-->
                    <!-- header -->            
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Inici activitat 501 - Classes, biblioteques i tipus composts</h2>
                             </div>
                        </div>
                    </div>
                    <!-- body -->            
                    <div class="row">
                        <div class="col-lg-12">
                             <div class=bodySlide>
                                 <p>Tal i com hem vist a l'aplicar el disseny descendent i l'ús de funcions, els programes resulten molt més llegibles, fàcils d'escalar i de localitzar errors si els dividim en parts, que no si fem l'aplicació, escrivint el codi tot seguit a la funció principal.</p>
                <p>No obstant, a mesura que el programa es fa més gran i complex, necessitem distribuir encara més la informació i, en ocasions, re-aprofitar parts de codi d'altres programes. Així doncs, aquí anirem més enllà; el que farem serà agrupar diferents funcions o mètodes que facin referència a un mateix tema, constituint el que anomenarem <b>mòduls</b>. A JAVA, aquests mòduls els implementarem com a classes independents, cada mòdul estarà contingut en una <b>classe</b>, dins de la qual hi disposarem les funcions específiques del mòdul. Per tant, el que definirem a partir d'ara, a més de les funcions, seran també les classes contenidores (d'aquestes funcions), les quals permetran mantenir el codi ben organitzat en mòduls.</p>
                <p>Per últim, també veurem que en moltes ocasions els tipus de dades que coneixem fins ara (variables simples, arrays,...) no són suficients per representar les dades d'un programa. 
                Per això, definirem el que s'anomenen <b>tipus composts</b> com una agrupació de dades de diferents tipus i veurem com es gestionen en JAVA. 
                                 <p>Aquesta activitat us permetrà aprendre com implementar i fer servir <em>classes, biblioteques i tipus composts</em>, de manera que us serveixi de pràctica per posteriors implementacions del projecte.</p>
                                 <p>En primer lloc haureu de llegir l'apartat <em><a href="#slc-toKnow">Què cal saber</a></em>. Allà, se us explicaran els coneixements bàsics que necessitareu per dur a tyerme l'activitat. </p>
                                 <p>Després caldrà que feu els exercicis que se us demana a l'apartat <em><a href="#slc-toDo">Què cal fer</a></em>. Es tracta d'un conjunt d'exercicis que us ajudaran a consolidar l'aprenentatge dels conceptes explicats.</p>
                                 <p>A l'apartat <em><a href="#slc-toDelivery">Lliurament</a></em>, se us dóna la informació bàsica per poder fer el lliurament de l'activitat. No us oblideu de llegir l'apartat i seguir les seves indicacions</p> 
                                 <p>Finalment, a l'apartat <em><a href="#slc-toContinue">Com continuar</a></em>, us redirigirà a la següent activitat. </p> 
                             </div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toStart ================-->    

            <!--=========== BEGIN SECTION  toknow ================-->    
            <section id="slc-toKnow" class="vsections">
                <!--=========== BEGIN SUBSECTION Definició classe ================-->    
                <section id="slc-toKnow10" class=" section">
                    <div class="container">  <!--Bootstrap container-->
                        <!-- header -->            
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Què és una classe?</h3>
                                 </div>
                            </div>
                        </div>
                        <!-- body -->            
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Com hem vist fins ara, el disseny descendent ens ha permès tenir el codi d'un programa ben endreçat en funcions. No obstant, això no és suficient quan el programa creix en mida i complexitat, ja que, aleshores, els programes necessiten dividir-se en tal quantitat de mètodes, que si els implementem en una única classe, ens generarà un fitxer molt llarg de llegir, difícil de relacionar i de localitzar-hi errors.</p>
                                    <p>Els noms de les funcions, també se'ns complicaran perquè caldrà trobar noms significatius però diferents per a cada funció. Podem intentar seguir un patró sistemàtic per anomenar les funcions, però sovint, els patrons són insuficients quan la quantitat de noms augmenta desmesuradament. Aviat ens trobarem amb aspectes que no havíem contemplat en el patró, i o bé caldrà fer una excepció, o bé caldrà reanomenar de nou tots els mètodes incorporant el nou aspecte. Sigui quina sigui la solució presa, el ritme d'implementació se'n ressentirà.</p>
                                    <p>La solució a aquest problema, consisteix en dividir el codi en components jeràrquics més fàcils de modificar, les classes, on cadascuna d'elles agrupa un conjunt de funcions o mètodes que realitzen tasques relacionades. Gràcies a les classes, podrem codificar dues funcions amb el mateix nom, en classes diferents, sense que això representi cap problema durant l'execució. A més, cada classe pot seguir el seu patró específic de nomenclatura, de manera que un canvi no hagi d'implicar el reanomenament de totes les funcions de l'aplicació, sinó només dels mètodes de la classe afectada (pocs en comparació amb tots els de l'aplicació).</p>
                                    <p>La divisió en classes presenta encara una altra avantatge, ja que les classes, en JAVA, s'implementen en fitxers diferents. Això facilita el reaprofitament de codi en altres contextos i aplicacions, ja que en tindrem prou en referenciar el fitxer de codi a reaprofitar.</p>
                                    <p class="iocimportant"> Arribats a aquest punt, cal deixar molt clar que hem de defugir tant com sigui possible dels programes monolítics, on tot el codi es concentra en una única classe. Si volem enfrontar-nos a la implementació d'aplicacions de debò, cal que ens acostumem a modularitzar el codi.</p>
                                    <h4>Usos de les classes durant la implementació</h4>
                                    
                                    <p>Cal adonar-se que en realitat les classes són contenidors de codi. De moment, seguint el paradigma de la programació estructurada, direm que en funció del contingut de les classes els podem donar diferents usos en la implementació d'una aplicació. A mode d'esquema direm que les classes poden ser:</p>
                                    <ul>
                                        <li><strong>Classes específiques de l'aplicació</strong>: Són les classes que contenen la funcionalitat específica d'un programa. En aplicar disseny descendent, el codi queda distribuït en diferents funcions que agruparem per afinitat en diverses classes. Distingirem al menys, dos tipus: 
                                            <ul>
                                                <li><b>Classe principal</b>: és la classe que conté el mètode <strong><em>main</em></strong>, el qual representa el punt d’inici de l'aplicació a partir del qual comença el flux d'execució del programa cap a la resta de mètodes addicionals.</li>
                                                <li><strong>Mòduls en que es divideix un programa</strong>: En aplicacions grans, és necessari organitzar la funcionalitat en mòduls. Cada mòdul s'implementarà, com a mínim, en una classe diferent.</li>
                                            </ul>
                                        </li>
                                        <li><b>Repositori de funcions o biblioteques</b>: Correspondrien a un conjunt de funcions reaprofitables, definides per l'usuari o bé pel propi llenguatge JAVA. Per exemple, la classe <code>Scanner</code>, que ofereix un repertori de mètodes per controlar la lectura de dades des del teclat (<code>nextLine()</code>, <code>nextInt()</code>, <code>hasNextFloat()</code>, etc.). </li>
                                        <li><b>Dades especials</b>: Per exemple, la classe <code>String</code>, utilitzada per referir-se a cadenes de text dins de JAVA. Algunes classes de JAVA permeten manipular dades complexes mitjançant la crida de mètodes (<code>charAt(…)</code>,<code>indexof(…)</code>, etc.).</li>
                                        <li><b>Tipus compostos</b>: Les classes ens permeten mantenir ben agrupat un conjunt de dades diverses. Això resulta molt útil perquè amb una única variable podem accedir a tot el conjunt de dades.</li>
                                    </ul>
                                    <p>Aquesta és una visió específica del paradigma de la programació estructurada, quan arribeu al paradigma de la programació orientada a l'objecte, veureu que les classes són en realitat, molt més del que hem explicat aquí. De moment però ens quedarem amb aquesta visió.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION definició classe  ================-->    
                
                <!--=========== BEGIN SUBSECTION programa modular ================-->    
                <section id="slc-toKnow20" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Estructura d'un programa modular en JAVA</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Els programes modulars, tenen les seves funcions distribuïdes en diferents mòduls (classes en JAVA). Les raons per les que ens pot interessar dividir una aplicació en mòduls pode ser diversos, però els més comuns són:</p>
                                    <ul>
                                        <li>Quan tenim molts mètodes</li>
                                        <li>Quan tenim mètodes que fan referència a un mateix concepte</li>
                                        <li>Quan tenim mètodes que podríem reaprofitar a altres programes</li>
                                    </ul>
                                    <p>Sigui com sigui, és important, abans de començar la distribució de les funcions en classes, definir un criteri clar que ajudi a distingir i diferenciar cada mòdul, de manera que ens pugui resultar fàcil ubicar les funcions en un o altre mòdul, segons el que faci cada una d'elles.</p>
                                    <div class="figscope">
                                        <figure id ="figura_flux" class="left">
                                            <img width="564" src="images/activities/ic10m3u5_02.png" alt="flux de control en un programa amb classes addicionals">
                                            <figcaption style="width: 610px; max-width: 75%;">
                                                <span class="figuretitle">figura </span> Comparació del flux de control en un programa monolític i en un de modular.
                                            </figcaption>
                                        </figure>
                                        <p>Els programes modulars, a més de les classes amb els mòduls, necessiten també una classe principal, des d'on es comenci a executar l'aplicació. És a dir, una classe on es defineixi el mètode <code>main</code>. La resta de classes i funcions només s'executaran quan es realitzi una crida, per tant, per cada aplicació només hi pot haver una única classe principal amb un únic mètode <em>main</em>, el qual s'encarregarà d'iniciar les crides a les diferents funcions de les classes que conformen el programa, de forma semblant a com succeeix quan s'executa un programa organitzat en diverses funcions però implementat amb una única classe. Vegeu la <span class="figref">figura</span> per visualitzar la comparació. </p>
                                    </div>
                                    <p>Per poder cridar un mètode d'una classe diferent a la classe des d'on es fa la crida, cal disposar d'una instància de la classe on es trobi el mètode a cridar. En JAVA, les instancies s'aconsegueixen usant la instrucció <em><strong>new</strong></em> seguida del nom de la classe a instanciar. Encara que no és imprescindible, el més normal és emmagatzemar les instàncies en variables. Les variables actuen com a referències per poder fer les crides als mètodes continguts a la classe. Per exemple, si volguéssim obtenir una instància d'una classe anomenada <em>CalculsEstadistics</em>, per tal de poder executar algun càlcul estadístic (funcions implementades a la classe), caldria definir una variable de tipus <em>CalculsEstadistics</em>, assignar-hi una instància i fer les crides a les funcions estadístiques pertinents:</p>
                                    <pre><code class="java">
...
double[] dades;
double resultat;
...
//declaració de la variable que contindrà la instància de la classes
CalculsEstadistics instanciaCalculs = new CalculsEstadistics();
...
//us de la instancia per cridar algunes de les seves funcions
resultat = instanciaCalculs.mitjana(dades);
...
</code></pre>
                                    <p>Fixeu-vos que la instanciació és semblant a la que habitualment realitzeu en el mètode <em>main</em> en crear una instancia del programa i cridar la funció inici:</p>
                                    <pre><code class="java">
public class UnProgramaQualsevol {

    static void main(String[] args) {
        UnProgramaQualsevol programa = new UnProgramaQualsevol();
        programa.inici();
    }
    
    void inici() {
         ...
    }
...
}
</code></pre>

                                    <p>Efectivament. Per poder cridar les funcions d'una classe, des del mètode <em>main</em> cal disposar d'una instància de la classe.</p>
                                    <p class=iocimportant>A mode de resum podem dir que per fer crides a mètodes implementats a la pròpia  classe des d'on es fa la crida, no cal disposar d'instancia excepte si la crida es fa des del mètode <em>main</em>. Qualsevol crida a un mètode situat fora de la classe des d'on es fa la crida, precisarà d'una instancia per referenciar el conjunt de mètodes de la classe.</p>
                                    <p>Veiem a continuació un exemple sencer a fi que disposeu d'una idea global de com cal fer les crides quan treballem amb diverses classes:</p>
                   <pre><code class="java">
public class RegistreNotes {

    public static void main(String[] args) {
        //Instanciació del programa des del mètode main
        RegistreNotes programa = new RegistreNotes();
        //crida a la funció inici a través de la instància del programa
        programa.inici();
    }

    void inici() {
        double max;
        double min;
        double mitjana;
        double[] notes = {2.0, 5.5, 7.25, 3.0, 9.5, 8.25, 7.0, 7.5};

        //Instanciació de la classe CalculsArrayReals per tal de poder cridar les seves funcions
        CalculsArrayReals calculador = new CalculsArrayReals();

        //Un cop feta la instància, ja es poden fer les crides usant com a prefix la variable amb la instància.
        max = calculador.calcularMaxim(notes);
        min = calculador.calcularMinim(notes);
        mitjana = calculador.calcularMitjana(notes);
        
        //crida a un funció de la mateixa classe. No cal instanciació
        mostrarResultats(max, min, mitjana);
    }
    
    void mostrarResultats(double max, double min, double mitjana){
        System.out.println("La nota màxima és " + max + ".");
        System.out.println("La nota mínima és " + min + ".");
        System.out.println("La mitjana de les notes és " + mitjana + ".");
    }
}
            </code></pre>
                <p>La classe <em>CalculsArrayReals()</em> estaria definida en altre fitxer i es podria fer servir en diversos projectes:</p>
                <pre><code class="java">
public class CalculsArrayReals {
    double calcularMaxim(double[] array) {
        double max = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (max &lt; array[i]) {
                max = array[i];
            }
        }
        return max;
    }
    
    double calcularMinim(double[] array) {
        double min = array[0];
        for (int i = 1; i &lt; array.length; i++) {
            if (min &gt; array[i]) {
                min = array[i];
            }
        }
        return min;
    }
    
    double calcularMitjana(double[] array) {
        double suma = 0;
        for (int i = 0; i &lt; array.length; i++) {
            suma = suma + array[i];
        }
        return suma/array.length;
    }
}
                </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION programa modular ================-->    
                
                <!--=========== BEGIN SUBSECTION Biblioteques de JAVA: API ================-->    
                <section id="slc-toKnow40" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >L'API de JAVA</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Sovint els llenguatges de programació incorporen mòduls completament desenvolupats amb funcions genèriques que ens poden ajudar a desenvolupar molt més ràpidament que si haguéssim d'implementar-les nosaltres. Es coneixen com a biblioteques o utilitats del llenguatge i en general resolen tasques de propòsit general que poden ser d’utilitat en una àmplia gamma de programes.</p>
                                    <div class="iocnoteOpener">
                                        <a href='#' role="button" data-toggle='tooltip' role= "tooltip" title="Què són els paquets o packages?" data-target="queSonPaquets" data-note-by="paquets">
                                            <img src="images/nota2.png" alt="nota sobre paquets" style="width: 100%;"/>
                                        </a>
                                        
                                            <span id="queSonPaquets" class="iocnoteSlidePane toggle-off">
                                                Els paquets organitzen les classes de <em>Java</em> de forma equivalent a com els directoris organitzen el fitxers d'un sistema informàtic. En aquest sentit, direm que els paquets poden contenir classes i també altres paquest. De forma semblant als fitxers, les classes es poden anomenar de forma absoluta (nom complert), indicant tota la jerarquia de paquest on està continguda o bé de forma relativa (nom curt), indicant només el nom de la classe. Per poder fer servir una classe d'un biblioteca de tercers cal importar-la indicant el seu nom complert (forma absoluta). Un cop importada es pot fer servir el nom curt (forma relativa). A diferencia dels directoris del sistema de fitxers, els paquets de Java se separen entre ells fent servir <em>un punt </em>com a símbol separador.   
                                            </span>
                                    </div>
                                    <p>En el cas del llenguatge Java, el seu kit de desenvolupament (JDK) incorpora un quantiós repositori de classes, organitzats en diferents <em><span id=paquets>paquets</span> (packages)</em>  d’acord a la seva temàtica, que poden ser accedides lliurement en realitzar qualsevol programa. Aquest repositori és el que s’anomena l’<b>API</b> de JAVA. </p>
                                    <p>La <a class="apiJavaUrl" target="_blank">documentació de l’API de JAVA</a> ofereix un enorme repertori de classes que contenen mètodes amb funcionalitats molt diverses.</p>
                                    <p>Els <em>packages</em> que contenen les classes més usuals són:
                                                <ul>
                                                    <li><code>java.lang</code>: conté totes les classes vinculades a operacions essencials dels tipus de dades del llenguatge.</li>
                                                    <li><code>java.util</code>: una mena de calaix de sastre amb classes de propòsit general.</li>
                                                    <li><code>java.io</code>: conté totes les classes vinculades a entrada / sortida (tractament de fitxers).</li>
                                                    <li><code>javax.swing</code>: conté les classes bàsiques vinculades a la creació d’interfícies gràfiques.</li>
                                                </ul>
                                                <p>L’avantatge de conèixer aquests paquets és que, com que aquestes classes ja estan creades i incorporades com a part del llenguatge, si en trobeu una que ja faci la feina requerida, us estalviareu haver d’escriure parts de codi font del programa. Podeu trobar informació detallada de <a class="apiJavaUrl" target="_blank">l'API a l'adreça oficial de JAVA</a>. Si coneixeu el nom de la classe, podeu cercar directament a <em>Google</em>, afegint la paraula API al nom de la classe i us portarà directament a la documentació específica de la classe indicada.</p>
                                                <p>Per poder usar qualsevol classe d’entre les definides a l’API de JAVA, cal abans indicar que la volem fer servir amb la instrucció <strong><em>import</em></strong>. La instrucció <em><strong>import</strong></em> indicarà a la màquina virtual que cerqui el fitxer corresponent i el carregui per poder crear instàncies fer servir els seus mètodes.</p>
                                                <p>Un cop feta la importació, la sintaxi per invocar els seus mètodes és exactament la mateixa que l'explicada.</p>
                                                <p>Per exemple, suposeu que heu de fer un programa que ha de generar dos valors reals a l’atzar, entre 0 i 100, i voleu que els mostri per pantalla. D’entrada, resoldre aquest problema suposaria haver de crear dins del codi font algun mètode que generés aquests valors reals aleatoris. Ara bé, JDK disposa ja d'una classe anomenada Random que fa aquesta feina i que podem fer-la servir sense haver d'implementar-la.</p>
                                                <p>Cercant-la a la documentació de l’API de Java, es veu que forma part del <code>package java.util</code>. A continuació veiem com es pot fer servir aquesta classe:</p>
                                    
                                 <pre><code class="java">
//Importació de la classe, en estar en un altre package
import java.util.Random;

public class RealsAleatoris {
    public static void main(String[] args) {
        RealsAleatoris programa = new RealsAleatoris();
        programa.inici();
    }
    public void inici() {
        Random instanciaRandom;
        double valorDoubleAleatori1;
        double valorDoubleAleatori2;
        
        //Instanciació de la classe Random
        instanciaRandom = new Random();
        
        //Generar un valor a l'atzar
        valorDoubleAleatori1 = instanciaRandom.nextDouble();
        //Generar-ne un altre
        valorDoubleAleatori2 = instanciaRandom.nextDouble();
        ...
    }
}
</code></pre>
                                    <p> Com que forma part de l’API de Java, l’ús de la classe Random no implica la incorporació de cap altre fitxer de codi font. Un cop ja està tot llest per usar-la, caldrà mirar quins mètodes ofereix per generar reals a l’atzar.</p>   
                                     <p>Cal destacar que el procés tot just descrit ja l’heu usat anteriorment en diverses ocasions, per exemple, cada cop que us calia llegir dades pel teclat i heu usat <em>Scanner</em>. Si mireu la documentació de l’API de JAVA, trobareu aquesta classe dins el mateix paquet <em>java.util</em>.</p>     
                                     <p class=iocimportant> Hi ha però, una excepció amb les classes del paquet <em>java.lang</em>. Donada la importància d'aquestes no és necessari fer cap importació  per poder-les usar. En aquest paquet trobarem les classes de dades com <em>String</em>, <em>Double</em>, <em>Integer</em>, <em>Boolean</em>, etc. Classes bàsiques com <em>System</em> o utilitats imprescindibles com la classe <em>Math</em>.</p>
                                     <h4 >Instanciació de classes amb paràmetres</h4>
                                     
                                     <p>Algunes classes de Java tenen una particularitat, i és que a l’hora d’inicialitzar-les cal especificar un conjunt d’informació addicional en forma de <b>paràmetres</b>.                                      
                                                 <p>Fins al moment, s’ha dit que per inicialitzar una classe per tal de poder invocar els mètodes que ofereix calia fer:</p>
                                                  <pre><code class="java">
NomClasse identificador = new NomClasse();
                                                  </code></pre>   
                                                 <p>Però hi ha casos en què, per inicialitzar correctament la classe, cal afegir un conjunt de valors entre els parèntesis, de manera idèntica a com es faria en invocar un mètode. Si no es posen aquests paràmetres quan pertoca, hi haurà un error de compilació.</p>                       
                                                    <pre><code class="java">
NomClasse identificador = new NomClasse(paràmetres);
                                                  </code></pre>   
                                                  <p>Per exemple, la classe <em>Scanner</em>. Per inicialitzar-la correctament li cal un paràmetre indicant quin sistema d’entrada ha de processar:</p>
                                                  <pre><code class="java">
Scanner lector = new Scanner(System.in);
                                                  </code></pre>   
                                                  <p>La classe Random també permet inicialitzar-se amb paràmetres. Concretament se li pot passar un número, a fi que s'incrementi el potencial aleatori. Normalment se li passa el valor numèric retornat pel rellotge del sistema expressant el nombre de milisegons transcorreguts.</p>
                                                  <pre><code class="java">
Random random = new Random(System.currentTimeMillis());
                                                  </code></pre>   
                                                  <p>Per veure si cal o no incloure un paràmetre en inicialitzar una classe, caldrà cercar-lo a la seva documentació. Concretament, a l’apartat anomenat resum de constructors (<em>Constructor Summary</em>) indica la sintaxi de la part dreta de la inicialització. Feu la consulta dels <a class="apiRandomUrl" target="_blank">constructors de la classe Random</a> i veureu que accepta ambdues formes, amb paràmetres (un valor numèric de tipus long anomenat <em>seed</em>) i sense.</p>                       
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Biblioteques de JAVA: API ================-->        

                <!--=========== BEGIN SUBSECTION Mètodes estàtics ================-->    
                <section id="slc-toKnow41" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Mètodes estàtics</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Tot i que, com s'ha comentat, per poder invocar mètodes d’una classe cal instanciar-la prèviament fent servir la sentència <em>new</em>, JAVA permet definir excepcions de forma que es pugui fer una crida a funcions d'una classe sense necessitat d'haver de crear cap instància. Són el que mètodes semblants als altres, però es troben marcats amb la paraula <em>static</em>. Això indic a JAVA que es poden fer servir sense necessitat de crear una instancia.</p>
                                    <p>Trobarem alguns exemples a l'API de JAVA. A la documentació distingirem aquestes funcions perquè apareixen marcats amb la paraula clau <code>static</code>. Trobareu alguns exemple a la classe String: <a class="apiStringFormatUrl" target="_blank">format</a>, <a class="apiStringValueOfUrl" target="_blank">valueOf</a> i a tots els mètodes de la classe <a class="apiMathUrl" target="_blank"><em>Math</em></a>.</p>
                                                <p>Per invocar aquests mètodes, la sintaxi correcta és posar com a prefix el nom de la classe directament. A part d’això, el seu comportament és idèntic a qualsevol altre mètode. És a dir, la sintaxi és: </p>                                    
                                    <pre><code class="java">
NomClasse.nomMetode(paràmetres);
                                    </code></pre>   
                                    <p>Per exemple, donat el mètode estàtic <code>sqrt</code> definit a la classe <code>Math</code>: </p>
                                       <pre><code class="java">
double resultat = Math.sqrt(36);
                                    </code></pre> 
                                    <p>A continuació veurem els mètodes estàtics d'algunes de les classes més importants:</p>
                                    <ul>
                                                <li><b>La classe Math: </b>Pertany al <em>package</em> <code>java.lang</code>, i per tant pot ser usada sense haver d’importar-la. 
                                                Ofereix un ventall de mètodes estàtics per realitzar operacions matemàtiques avançades com: arrodoniment de valors(<code>round(valor)</code>), potència(<code>pow(base, exponent)</code>), arrel quadrada (<code>sqrt(valor)</code>), màxims i mínims (<code>max(a, b)</code>, <code>min(a, b)</code>),...Per exemple:
 <pre><code class="java">                                                
package ioc.m03.uf2.funcions.a501;
import java.util.Random;

public class ArrodonirReal {
    public static void main(String[] args) {
        ArrodonirReal programa = new ArrodonirReal();
        programa.inici();
    }
    public void inici() {
        //Inicialització de Random
        Random rnd = new Random();
        //Ús per generar un real entre 0 i 1
        double valor = rnd.nextDouble();
        System.out.println("El valor real generat és " + valor);
        //Ús del mètode estàtic. No cal inicialitzar res, es pot usar directament.
        //No cal importar-la, ja que pertany a java.lang
        long arrodonit = Math.round(valor);
        System.out.println("El valor arrodonit és " + arrodonit);
    }
}
</code></pre>  
                                                </li> 
                                                <li><b>La classe Array:</b>Pertany al <em>package</em> <code>java.util</code> (com Random i Scanner). 
                                                Ofereix mètodes estàtics per fer operacions típiques amb arrays (ordenacions(<code>sort(array)</code>), còpies(<code>copyOfRange(array, posInici, posFi)</code>) , cerques(<code>binarySearch(array, clau)</code>), igualtats (<code>equals(array1, array2)</code>), conversió a text (<code>toString(array)</code>), etc.). 
                                                Per usar-los cal tenir present que alguns d’aquests manipulen els paràmetres d’entrada de tipus compost, en aquest cas arrays. Per tant, en finalitzar la invocació, l’array original haurà canviat.
                                                A continuació podem veure un exemple:
<pre><code class="java">                                                
package ioc.m03.uf2.funcions.a501
import java.util.Arrays;

public class OrdenaArrayText {
    public static void main (String[] args) {
        OrdenaArrayText programa = new OrdenaArrayText();
        programa.inici();
    }
    public void inici() {
        String[] array = {"Un", "Dos", "Tres", "Quatre", "Cinc"};
        Arrays.sort(array);
        System.out.println("Els elements ordenats són:");
        for (int i = 0; i &lt; array.length; i++) {
            System.out.println(array[i]);
        }
    }
}    
</code></pre> 
                                            
                                                </li>                                 
                                    </ul>      
                                    <p>De forma semblant a com s'han codificat les classes de l'API que tenen mètodes estàtics, nosaltres podem també caracteritzar d'estàtiques les nostres funcions. N'hi ha prou de posar la paraula clau <em>static</em> just després del modificador <em>public</em>, però davant de la resta de la declaració de la funció, de forma idèntica a com hem declarat fins ara el mètode <em>main</em> de la nostra classe principal. Per exemple:</p>              
                                    <pre><code class="java">
public class ClasseExemple{

    public static funcioEstatica1(/* Declaració normal de paràmetres si s'escau */){
        /* Codi de la funció */
        ...
    }
    
    public static funcioEstatica2(...
        ...
    }
    
    ...
}
                                    </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Mètodes estàtics ================-->       
                
                <!--=========== BEGIN SUBSECTION Estructures de dades: Tipus composts ================-->    
                <section id="slc-toKnow50" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Estructura de dades: Tipus composts</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                <p>Com ja heu anat veient amb l'experiència que porteu programant, quan implementem una aplicació gran, la quantitat de dades es multiplica. En aquests casos, l'ús de variables globals està totalment desaconsellat perquè treballar amb moltes variables a l'hora pot comportar molts errors, a més de la poca eficiència que suposa definir un nombre desmesurat de variables.</p>
                                <p>Malgrat tot, l'alternativa de treballar amb variables locals no és menys arriscada ja que sovint, en els processos de nivell alt podem arribar a necessitar moltes variables i pot ser realment tediós haver-les de passar per paràmetres i per descomptat, en el fons no deixa de ser també una font d'errors.</p>
                                <p>Sortosament, ja hem vist que podem fer servir arrays per agrupar dades. Ara bé, no totes les dades es poden emmagatzemar en arrays, i ni que així fos, una aplicació gran podria necessitar també un nombre gran d'arrays. Caldrà doncs, cercar altra solució que ens permeti agrupar dades amb independència del seu tipus. </p>
                                <p>La majoria de llenguatges de programació permeten la creació d'<b>estructures de dades</b> per poder pal·liar el problema de la disgregació de dades. Es tracta d'una forma d'agrupar dades de diferent tipus fent servir una única variable.</p>
                                <p>L'estructura de dades és ideal per aplicacions grans ja que permet organitzar les dades de forma jeràrquica i obtenir subconjunts de dades coherents escollint el tros adequat de la jerarquia. Quan parlem d'estructura jeràrquica ens referim a algun sistema en que unes dades s'englobin dins d'altres formant un arbre. Per tal que això sigui possible, cal procurar agrupar les dades relacionades sota un mateix concepte.</p>
                                <p>Seleccionar la jerarquia correcta no sempre es senzill. Si l'aplicació es petita, és possible agrupar totes les dades en un sol bloc, o crear un número reduït de blocs independents. Internament, cada bloc tindrà un conjunt de dades de diversos tipus (enters, cadenes, arrays,...) però organitzades de forma que siguin conceptualment coherents.</p>
                                                <p class="iocimportant">Les estructures de dades són organitzacions més o menys complexes de dades, de tal forma que la seva organització ens configura un valor extra que ens ajuda a interpretar la informació que representen. Per exemple, hem de considerar una estructura de dades el conjunt de valors que poden identificar i representar una persona: el seu nom, la seva edat, el seu DNI, les titulacions que posseeix, els treballs que ha realitzat, etc.</p>
                                                <p>Els llenguatges de programació donen suport a les estructures de dades per mitjà dels tipus compostos de dades i concretament, el llenguatge JAVA, fa servir classes per definir els seus tipus de dades compostos.</p>
                                                <p class="iocimportant">Els tipus de dades compostos (classe en el llenguatge JAVA) permeten definir com s'identifiquen i organitzen els valors entre sí. Com identificadors usarem noms conceptuals que ens ajudin a interpretar el que representen.</p>
                                                <p>Per exemple, si haguéssim d'implementar una calculadora que hagués de fer les 4 operacions bàsiques entre dos números qualsevol, el tipus compost a fer servir podria ser:</p>
                                                                                    
                                    <div class="iocexample">
                                         
                                    <pre><code class="java">
package ioc.m03.uf2.funcions.a501;
public class DadesCalculadora {
    double operador1;
    double operador2;
    char operacio;    
    double resultat;
}
                                         </code></pre>
                                    </div>
                                    <figure id ="figura_instanciacio" class="left">
                                        <img width="464" src="images/activities/tipusCompostInstancia.png" alt="instanciació de tipus compostos">
                                        <figcaption class="figscope" style="width: 510px; max-width: 75%;">
                                            <span class="figuretitle">figura </span> Instanciació d'un tipus compost.                               
                                        </figcaption>
                                    </figure>
                                    <p>Fixeu-vos que els tipus compostos no són les dades pròpiament. En realitat els tipus compostos són el que defineix quina forma han de tenir les dades, de quins tipus ha de ser, quins seran els identificadors dels diferents valors i quina la organització interna. Ara bé, i les dades? com hi afegim les dades? Abans d'explicar-ho m'agradaria remarcar que les dades no s'emmagatzemen a l'estructura. El llenguatges de programació només poden emmagatzemar dades a la memòria i és allà on aniran a parar les dades. Així doncs, per a què serveixen aleshores els tipus compostos? Doncs l'explicació que més s'hi aproxima és que actuen de plantilla. Així, els tipus compostos emmotllen la memòria per poder-hi emmagatzemar dades en la forma definida en cada tipus compost. En l'argot dels llenguatges de desenvolupament, en comptes de parlar d'emmotllar, es parla d'instanciar (figura 1). De fet, les dades de la memòria són instancies d'algun tipus de dades (siguin o no compostos).</p>
<p>Cada tipus compost pot instanciar múltiples dades a la memòria de forma simultània. Cada dada manté els seus propis valors.
A la pràctica, la instanciació es fa sobre una variable i es fa servir la paraula clau <em>new</em> seguida del tipus compost a instanciar amb els parèntesis d'execució:</p>
                                         <pre><code class="java">
DadesCalculadora operacio1 = new DadesCalculadora();
DadesCalculadora operacio2 = new DadesCalculadora();
                                         </code></pre>
                                    
                                    <p> A partir d'una instancia de tipus compost (variable), podem accedir als seus elements per modificar o obtenir el seu valor escrivint després del nom de la variable, un punt seguit del nom de l'element. Exemple:</p>
                                         <pre><code class="java">
operacio1.operador1 = 5;
operacio1.operador2 = 3;
operacio1.operacio = '+';
...
if(operacio1.operacio == '+'){
    operacio1.resultat = operacio1.operador1 + operacio1.operador2;
} 
                                         </code></pre>
                                    <p>En el llenguatge JAVA no és possible donar valors a una estructura si no s'ha creat la instancia del seu tipus compost. Si ho féssim obtindríem un error:</p>
                                         <pre><code class="java">
DadesCalculadora operacio2;
operacio2.operador1 = 7; //Això dona error perquè no s'ha instanciat la variable: operacio2 = new DadesCalculadora() 
                                                </code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Estructures de dades: Tipus composts ================-->  
            </section>                             
            <!--=========== END SECTION toknow ================-->    

            <!--=========== BEGIN SECTION toDo ================-->    
            <section id="slc-toDo" class="vsections">
                <!--=========== BEGIN SUBSECTION Descripció dels exercicis ================-->    
                <section id="slc-toDo10" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Descripció general</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>En aquesta activitat se us proposa fer 3 tasques que us ajudaran a consolidar el que se us ha explicat a la secció <em>Què cal saber</em>. La dues primeres estan relacionades amb la creació de biblioteques, la darrera amb la creació de tipus compostos de dades. Es tracta d'exercicis que us ajudaran a reflexionar sobre la reultilització de codi, indispensable a l'hora de dissenyar noves biblioteques, sobre la creació de repositroris estàtics de funcions o sobre com crear i fer servir tipus compostos de dades.</p>
                                    <p>A fi que refelxioneu sobre els temes plantejats, se us demanarà, debatiu algunes qüestions en el <span class="forumDeDiscussio"></span>. No dubteu en partidicipar-hi. Haver d'argumentar el vostre discurs us farà assolir millor els conceptes plantejats.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Descripció dels exercicis  ================-->    
                
                      <!--=========== BEGIN SUBSECTION Debat 1 ================-->    
                <section id="slc-discussion11" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer? Classes, biblioteques i tipus composts</h2>
                                     <h3> Tasca 1. Debat sobre la reutilització </h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p> Segurament, un dels criteris que més avantatge ha suposat per el desenvolupament de programari, ha estat la reutilització del codi, perquè així s'aconsegueix codificar més ràpidament i es cometent molts menys erros. És evident que per poder reutilitzar codi en diferents contextos (diferents parts d'un programa, diferents aplicacions, etc.), cal separar aquelles parts que es poden reutilitzar, de les que difícilment podran reutilitzar-se a cap altra context. </p>
                                    <p>Ara bé, cal assenyalar que crear biblioteques de funcions reutilitzables no és trivial, ja que requereix d'un esforç d'abstracció important per tal d'aïllar el que és inevitablement específic d'una aplicació, del que es pot generalitzar afegint-hi paràmetres. Si no hi parem gaire atenció, tindrem tendència a barrejar-ho tot i ens resultarà impossible trobar entre el nostre codi cap funció genèrica.</p>
                                    <p>Per exemple, és habitual, en programadors poc experimentats, barrejar en una mateixa funció la demanda de dades a l'usuari, el tractament d'aquestes i la mostra del resultat. Penseu però que generalment, les demandes de dades a l'usuari i la mostra de resultats per pantalla, són realment processos molt específics i lligats  a l'aplicació en la que s'han desenvolupat. Això els converteix realment en processos difícilment reutilitzables. Per contra, els tractaments que reben les dades solen ser processos altament reutilitzables si aconseguim parametritzar-los amb una mica d'habilitat.</p>
                                    <p>A continuació se us presenta la funció <em>trobarTemperaturaMinima</em>, la qual permet trobar el valor mínim d'un conjunt de temperatures introduïdes per l'usuari. Fixeu-vos però que la funció no compleix els requisits indicats per poder ser considerada reutilitzable, ja que només es podria fer servir en algun context que calgués trobar la temperatura mínima d'una conjunt de temperatures donades per l'usuari. És a dir exclusivament l'actual!</p>
                                    <p>Tal com està codificada la funció no serviria per trobar les temperatures mínimes emmagatzemades en el disc dur, en comptes de demanar-les a l'usuari, ni molt menys per trobar el valor mínim de quelcom que no fossin temperatures, ni permetria emmagatzemar el valor mínim en el disc dur, o enviar-lo a un servidor, en comptes de mostrar-lo per pantalla, ja que la petició de dades, el càlcul del resultat i la mostra d'aquest formen un tot indivisible.</p>
                                    <pre><code class="java linenumbers">
public void trobarTemperaturaMinima(){
    float[] temperatures;
    int posMin;            
    System.out.println("Quantes temperatures vols omplir?");
    int mida = scanner.nextInt();
    temperatures = new float[mida];
            
    System.out.println("Entra el valor de les temperatures");
    for(int i=0; i&lt;temperatures.length; i++){
        System.out.println("Temperatura " + (i+1) + ": ");
        temperatures[i]=scanner.nextFloat();
    }

    posMin=0;
    for(int i=1; i&lt;temperatures.length; i++){
        if(temperatures[posMin]&gt;temperatures[i]){
            posMin=i;
        }
    }
    System.out.println("La Temperatura mínima és: " +  temperatures[posMin]);
}
                                     </code></pre>
                                     <p>Es demana que recodifiqueu la funció, dividint-la, de manera que agrupeu una part del codi en almenys una funció realment reutilitzable, poden ser més si ho creieu oportú (consulteu la pista 2 si us interessa). Acompanyeu la codificació amb un raonament que justifiqui la divisió realitzada i pengeu-ho al <span class="forumDeDiscussio">forum de discussió</span>.</p>
                                    <p>També es demana que reflexioneu en el fòrum, si les noves funcions substituirien totalment la funció <em>trobarTemperaturaMinima</em> de manera que caldria eliminar-la del codi, o si per contra, les noves funcions, necessitarien encara de la funció <em>trobarTemperaturaMinima</em> adaptada a la crida d'aquestes.</p>
                                     <p>Finalment se us demana que escolliu el codi que algun dels vostres companys hagi penjat en el fòrum. Intenteu que sigui ben diferent al que vosaltres hagueu penjat. Compareu ambdós codis (el vostre i el del company escollit) seguint les indicacions de l'informe de comparació d'aquesta activitat. Reserveu l'informe de comparació per fer el lliurament a la bústia de lliuraments.</p>

                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion11" 
                                            data-selector-clue="#slc-discussion11-clue1">
                                        Pista 1
                                    </button>                                        
                                    <div id="slc-discussion11-clue1" class="iocClue hidden">
                                        <h2>Pista 1</h2>
                                        <p>Identifica la part del codi destinada a preguntar a l'usuari els valors de les temperatures, la part del codi destinada a mostrar el resultat i la part del codi destinada a cercar el valor mínim.</p>
                                        <p>Creus que hi ha diferencia entre cercar la temperatura mínima, la nota mínima, el menor temps, o el menor consum de carburant? Si no hi ha diferencia, podríem idear una un procés comú a tots ells. Quines dades necessitaria el procés? Quin seria el resultat del procés?</p>
                                    </div>                                    
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion11" 
                                            data-selector-clue="#slc-discussion11-clue2">
                                        Pista 2
                                    </button>                                        
                                    <div id="slc-discussion11-clue2" class="iocClue hidden">
                                        <h2>Pista 2</h2>
                                        <p>Una altre aspecte a destacar de la reutilització i les biblioteques de funcions consisteix en l'aïllament o encapsulació de blocs de codi intercanviables, de manera que sigui possible evitar que una modificació pugui produir errades en multitud de llocs del programa.</p>
                                        <p>Per exemple en el cas que ens ocupa la font que proporciona els valors de les temperatures a tractat, és el mateix usuari, però no té perquè ser sempre així. De fet, sembla lògic que els valors de les temperatures puguin estar emmagatzemats en un fitxer o arribar a través d'Internet, etc. Si disposéssim d'una funció anomenada <em>obtenirValorsTemperatura</em> que retorni el conjunt de temperatures a analitzar amb independència d'on s'aconsegueixin, seria possible alternar la font origen de les dades sense tocar més codi que el que es troba dins d'aquesta funció, de manera que asseguraríem que la resta de programa funcionaria perfectament sigui quina sigui la funció d'obtenir les temperatures que finalment utilitzéssim.</p>
                                    </div>                                    
                                 </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Debat 1 ================-->     

                      <!--=========== BEGIN SUBSECTION Debat 2 ================-->    
                <section id="slc-toDo20" class=" section">
                </section>
                <!--=========== END SUBSECTION Debat 2 ================-->     

                <!--=========== BEGIN SUBSECTION Debat 3 ================-->    
                <section id="slc-toDo30" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer - Classes, biblioteques i tipus compostos</h2>
                                     <h3 >Tasca 3- Debat sobre els Tipus compostos </h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                <p>Imaginem una aplicació per jugar al senzill joc de les dames.  
                                Recordeu que es juga amb un tauler de 10x10 caselles, que juguen 2 jugadors i que cada jugador disposa de 12 fitxes de diferent color que cal disposar a certes caselles del tauler. 
                                Imaginem que l'aplicació vol identificar el nom dels dos jugadors i també el nombre de partides guanyades. </p>     
                                <p>Si decidim representar el tauler com una matriu de valors numèrics, en el que el valor -1 representi les caselles buides, el valor 0, representi les fitxes blanques i el valor 2, les negres; podríem crear les següents especificacions per donar resposta a les necessitats de l'aplicació:</p>
                                <div class="iocexample">        
                                    <table border="0" cellspacing="0" cellpadding="0" width="100%">
                                       <tr>
                                           <td>                                    
                                               <p>Opció 1)</p>                                  
                                               <pre><code class="java">
public class DadesJocDames {    
    int FITXA_BLANCA = 0;
    int FITXA_NEGRA = 1;
    int CASELLA_BUIDA = -1;

    int[][] tauler = 
                new int[10][10];
    int torn;
    String[] nomJugadors = 
                  new String[2];
    int[] victoriesPerJugador = 
                     new int[2];
}
    
                                               </code></pre>
                                           </td>                                                
                                           <td>  
                                               <p>Opció 2)</p>                                  
                                               <pre><code class="java">
public class DadesJocDames {    
    int FITXA_BLANCA = 0;
    int FITXA_NEGRA = 1;
    int CASELLA_BUIDA = -1;

    int[][] tauler = 
               new int[10][10];
    int torn;
    Jugador jugadorBlanques;
    Jugador jugadorNegres;
}

public class Jugador {    
    String nom;
    int partidesGuanyades;
}
                                               </code></pre>
                                           </td>
                                           <td>  
                                               <p>Opció 3)</p>                                  
                                               <pre><code class="java">
public class DadesJocDames {    
    int FITXA_BLANCA = 0;
    int FITXA_NEGRA = 1;
    int CASELLA_BUIDA = -1;

    int[][] tauler = 
               new int[10][10];
    int torn;
    Jugador[] jugadors = 
                new Jugador[2];
}

public class Jugador {    
    String nom;
    int partidesGuanyades;
}
                                               </code></pre>
                                           </td>

                                       </tr>
                                   </table>                          
                               </div>
                               <p>En cada una de les opcions, la classe <em>DadesJocDames</em> és l'estructura de dades que permetria identificar un moment determinat de la  partida que s'estigui jugant, com la posició de les fitxes, el torn del jugador que li toqui tirar o les dades especifiques de cada jugador (el seu nom i les partides que porta guanyades).</p>
                               <p>A la opció 2 i 3, la classe Jugador és l'encarregada  de mantenir les dades específiques referents a un jugador (el nom i les partides guanyades), mentre que a la opció 1 aquestes dades es troben repartides en dos arrays: <em>nomJugadors</em> i  <em>victoriesPerJugador</em>. La opció 3 es diferencia de la 2 en que els dos jugadors s'inclouen en un array de dues posicions en lloc de fer servir dos variables.</p>
                                <p>Et demanem que comparis les tres opcions i discuteixis al fòrum les següents preguntes sobre les estructures:</p>
                                <div class="frameBox">
                                    <h4>Qüestions pel debat en el <span class="forumDeDiscussio"></span></h4>
                                     <ol>
                                        <li>Creieu que les 3 estructures de dades DadesJocDames responen als requisits de l'aplicació?</li>
                                        <li>Quina instrucció utilitzaries per declarar una variable del tipus <em>DadesJocDames</em> i poder-la començar a fer servir, amb independència de quina sigui la opció utilitzada a la declaració?</li>
                                        <li>Per què creieu que a l'opció <em>1</em> no s'han unificat en un únic array els noms dels jugadors i les victòries aconseguides? L'array nomJugadors té una capacitat de dos elements, igual que victoriesPerJugador. Hi ha alguna raó que forci aquesta característica? Com es relacionen els elements d'ambdós arrays?</li>
                                        <li>A les opcions 2 i 3, es fa servir una tipus compost (<em>Jugador</em>) dintre de l'estructura principal. Això permet unificar dades de diferents tipus. Ara bé, en tractar-se d'un tipus compost, caldrà també inicialitzar-lo en algun moment. Com ho faries per cada opció?</li>
                                        <li>A vegades en estructures senzilles, l'ús de tipus compostos interns (com el de Jugador dins de DadesJocDames), pot resultat una mica farragós d'inicialitzar i usar. Cal valorar sempre quines avantatges i inconvenients comporten totes les opcions per poder fer una correcta. Quines avantatges i quins inconvenients creus que presenta cada una de les opcions?</li>
                                        <li>A banda de les inicialitzacions del tipus compostos Jugador, les tres opcions requeriran d'un petit procés d'inicialització que asseguri que abans de començar les dades seran coherents. És a dir, el taules es trobi buit i els comptadors de partides guanyades de cada jugador es trobi a zero. Com implementaries aquest procés?</li>
                                        <li>
                                            <p>Observa la imatge següent i explica què representa.</p>
                                            <img src="images/activities/instanciesDeDades.png" alt="instancies d'una estructura"/>
                                            <p>A quina o a quines de les 3 opcions de tipus compostos  del jocs de dames creus que serien compatibles amb aquestes instàncies, perquè?</p>
                                        </li>
                                        <li>Imagina que disposes d'una funció anomenada <em>demanarNomJugador</em> que demana a l'usuari que introdueix el seu nom i un cop escrit el retorni. Com assignaries el nom retornat a una variable del tipus <em>DadesJocDames</em>, anomenada <em>joc</em>? Contempla la solució per cada una de les 3 opcions?</li>
                                    </ol>
                                </div>
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-toDo30" 
                                            data-selector-clue="#slc-toDo30-clue1">
                                        Pista
                                    </button>                                        
                                    <div id="slc-toDo30-clue1" class="iocClue hidden">
                                        <h2>Pista</h2>
                                        <ol>
                                            <li>Per valorar si una estructura respon als requeriments d'una aplicació cal analitzar diverses situacions i valorar si és capaç d'emmagatzemar i recuperar tota la inforció requerida. En el cas que ens ocupa cal assegurar en cada moment la posició de les fitxes, el torn del jugador, el nom de cada un d'ells i el comptador de partides guanyades per saber qui d'ambdós acabarà guanyant.</li>
                                            <li><p>Recordeu que en JAVA les variables que representen Estructures de dades es declaren:</p>
                                                <div class="iocexample">
                                                     <pre><code class="java">
            NomEstructuraDeDades identificadorVariable;
                                                     </code></pre>
                                                </div>
                                                
                                                <p>I que abans de fer servir una variable d'algun tipus d'estructura de dades cal haver-la inicialitzat. 
                                                Si no es fa, a l'intentar usar-la obtindrem un error que aturarà l'execució. És possible inicialitzar les variables des de la pròpia declaració: </p>
                                                <div class="iocexample">
                                                     <pre><code class="java">
            NomEstructuraDeDades identificadorVariable = new NomEstructuraDeDades ();
                                                     </code></pre>
                                                </div> 
                                                <p>O bé després que s'hagin declarat:</p>
                                                <div class="iocexample">
                                                     <pre><code class="java">
            NomEstructuraDeDades identificadorVariable; 

            ...

            identificadorVariable = new NomEstructuraDeDades ();
                                                     </code></pre>
                                                </div> 
                                                <p>Però mai es poden fer servir abans d'haver-se inicialitzat.</p>
                                            </li>
                                            <li>Recordeu que els arrays son conjunts de dades d'un únic tipus.</li>
                                            <li>
                                                <p>Si els tipus compostos conteten altres estructures com arrays o altres tipus compostos, caldrà també inicialitzar-les en algun moment.</p>
                                                <p>Es poden inicialitzar dins la mateixa estructura: </p>
                                                <table border="0" cellspacing="0" cellpadding="0" width="100%">
                                                   <tr>
                                                       <td>                                    
                                                           <p>Opció 2)</p>                                  
                                                           <pre><code class="java">
public class DadesJocDames {    
    int FITXA_BLANCA = 0;
    int FITXA_NEGRA = 1;
    int CASELLA_BUIDA = -1;

    int[][] tauler = 
               new int[10][10];
    int torn;
    Jugador jugadorBlanques = new Jugador();
    Jugador jugadorNegres = new Jugador();
}
                                                          </code></pre>
                                                       </td>
                                                       <td>  
                                                           <p>Opció 3)</p>                                  
                                                           <pre><code class="java">
public class DadesJocDames {    
    int FITXA_BLANCA = 0;
    int FITXA_NEGRA = 1;
    int CASELLA_BUIDA = -1;

    int[][] tauler = 
               new int[10][10];
    int torn;
    Jugador[] jugadors = {new Jugador(), new Jugador()};
}

                                                           </code></pre>
                                                       </td>
                                                   </tr>
                                               </table>                          
<p>O bé en  el codi, abans de començar-les a fer servir: </p>
                                                                         <table border="0" cellspacing="0" cellpadding="0" width="100%">
                                       <tr>
                                           <td>                                    
                                               <p>Opció 2)</p>                                  
                                               <pre><code class="java">

DadesJocDames joc = new DadesJocDames();

joc.jugadorBlanques = new Jugador();


                                              </code></pre>
                                           </td>
                                           <td>  
                                               <p>Opció 3)</p>                                  
                                               <pre><code class="java">
DadesJocDames joc = new DadesJocDames();

joc.jugadors[joc.FITXA_BANCA] = new Jugador();

                                               </code></pre>
                                           </td>

                                       </tr>
                                   </table>                          

                                     </li>
                                            <li>Per valorar avantatges i inconvenients d'una estructura cal analitzar si està més o menys estructurada (hi ha jerarquia o bé es tracta les variables internes s'acumulen dins el contenidor sense un ordre clar.). També cal analitzar si son fàcils de fer servir, per això es poden mirar si els noms estan encertats si la jerarquia facilita recordar el nom i la seva utilitat, etc. Tingueu en compte que en general cal trobar un equilibri entre les estructures excessivament jerarquitzades (fàcils de dividir i mantenir agrupades, de recordar, etc, però per contra incrementen la complexitat ja que calen més inicialitzacions, cal escriure més, etc.) i les dades disperses (que són àgils de fer servir en nombre reduït, però requereixin de molta atenció si el nombre creix). </li>
                                             <li>
                                                <p>En JAVA qualsevol valor numèric s'inicialitza a zero per defecte, ja sigui com tipus bàsic o com un array de valors numèrics. És a dir:</p> 
                                                    <pre><code class="java">
        int valorEnter1;   // aquesta declaració assigna a la variable valorEnter el valor zero.
        int valorEnter2 = 0; //Aquesta declaració és doncs, equivalent a la de dalt.

        int[] arrayEnters1 = new int[3];  //aquesta declaració crea espai per a 3 enters inicialitzats amb el valor zero
        int[] arrayEnters2 = {0,0,0};  //aquesta declaració és equivalent a l'anterior, ja que fa espai per emmagatzemar 3 enters de valor zero

        int[] arrayEnters3;
        ...
        arrayEnters3 = new int[3] //Malgrat que es faci servir una inicialització en diferit de l'array, els enters segueixen prenent el valor zero per defecte.

                                                    </code></pre>
                                                <p> Si per fer funcionar el nostre programa, inicialment ens calen valors numèrics diferents de zero, serà necessari fer una inicialització d'aquest valors abans de començar-los a fer servir.</p>
                                                <p>A l'estructura dels joc de dames, quines dades numèriques necessiten inicialitzar-se amb valors diferents de zero?.</p>.
                                            </li>
                                             <!--li>
                                                       <pre><code class="java">
        //Exemples d'assignació i lectura dels valors        
        //OPCIÓ 2
        joc.jugadorBlanques.nom = demanarNomJugador();
        ...

        //OPCIÓ 1
        joc.jugador[joc.FITXA_NEGRE] = demanarNomJugador();

        //OPCIÓ 3
        joc.jugador[joc.FITXA_NEGRE].nom = demanarNomJugador();


                                                       </code></pre>
                                             </li-->
                                        </ol>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Exercici 2 ================-->   
            </section>
            <!--=========== END SECTION toDo ================-->    

            <!--=========== BEGIN SECTION toDelivery ================-->    
            <section id="slc-toDelivery">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Lliurament - Classes, biblioteques i tipus composts</h2>
                             </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-12">
                            <div class=bodySlide>
                                <p>Per fer el lliurament cal que, un cop hagueu realitzat els exercicis, obriu <span class="informeLliurament"></span>, l'ompliu i el lliureu a la <span class="bustiaLliurament"></span>, seguint les indicacions del propi document. No heu de lliurar el codi de les tasques, només l'informe. Es recomana acabar i lliurar aquesta activitat abans de la data recomanada: <strong class='dataRecomanada'></strong> i en tot cas mai després de la data límit: <strong class="dataLimit"></strong>.</p>
                                 <p>És molt important per el vostre aprenentatge que feu els exercicis proposats, que ompliu l'informe i que el lliureu. D'aquesta manera el professor podrà constatar  l'evolució del vostre l'aprenentatge sense que afecti la vostra qualificació i donar-vos consells o fer-vos propostes d'ajuda. També us demanem que ompliu la valoració de l'activat que trobareu al final de l'informe. Això ajuda a valorar la utilitat de l'activitat en el conjunt del procés d'aprenentatge i permet planificar millores, si fos necessari. </p>
                            </  div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toDelivery ================-->    
            
            <!--=========== BEGIN SECTION toContinue ================-->    
            <section id="slc-toContinue">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Com continuar</h2>
                             </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-12">
                            <div class=bodySlide>
                                <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en cosntrucció"> Text provisional. Estem treballant per millorar</div>                               
                                <p>Passeu a la següent  <a class="toNextActivity">activitat</a></p>
                                <p>Si us cal, també podeu saltar <a class="toActivityTable targetBlank">a la taula d'activitats</a> per accedir a qualsevol altra activitat.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toContinue ================-->    
        </div>
    </div>
    <!--=========== END MAIN SLIDER SECTION ================-->    

    <!--=========== BEGIN META-INFO PANELS ================-->    
    <div id="sidepanel-wrapper" class="left-position after-top-menu">
        <a id="panel-close" href="#" class="panel-close btn btn-light pull-right toggle"><i class="glyphicon glyphicon-remove-circle"></i></a>
        <div id="goals_info" class="bodySlide hidden"> 
            <h2>Objectius d'aprenentatge de l'activitat</h2>
            <ol>
            <li>    Descompodre un programa en funcions i classificar les funcions en mòduls (classes) d'acord a criteris ben definits i útils. Entre d'altres, són criteris bàsics els mòduls d'entrada i sortida, els mòduls de control, i els mòduls de tractament de dades.</li>
                <li>    Implementar biblioteques reutilitzables i específiques d'una aplicació.</li>
                <li>    Usar estructures de dades senzilles per agrupar les dades de l'aplicació en pocs accessos.</li>
                <li>    Identificar quan cal instanciar les estructures de dades i compassar-les a les diverses funcions. </li>
                <!--li>    Crear instancies de classes repositori de codi abans d'executar els seus mètodes escollint si es creen a nivell local o global. En qualsevol cas cal  vigilar no entrar en inicialitzacions recursisves que malbaratin o fins i tot exhaureixin la memòria.</li-->
                <!--i>    Documentar les diferents classes usant la sintaxi javadoc.</li-->
                <li>    Usar classes internes del llenguatge JAVA: String, Arrays, Math i Random.</li>
                <!--li>    Planificar les pantalles, controls i funcions d'alt nivell que estructuren un programa.</li-->
                <li>    Fer una transferència correcte de les dades mitjançant paràmetres durant l'execució. </li>
            </ol>
            <h2>Resultats d'aprenentatge del mòdul treballats en aquesta activitat</h2>
            <ul>
                 <li>Prova, depura, comenta i documenta els programes.</li>
                <li>Defineix el concepte de llibreries i la seva utilitat.</li>
                <li>Utilitza llibreries en l’elaboració de programes</li>
            </ul>
        </div>
        <div id="more_reinforcement" class="hidden"> 
            <h2>Més activitats i idees per reforçar l'aprenentatge</h2>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                               
            <p>Aquí s'afegiran exercicis, activitats, lectures o referencies externes per tal que l'estudiant, pugui reforçar el conceptes estudiats </p>
        </div>
        <div id="more_info" class="hidden"> 
            <h2>Informació sobre funcions  per ampliar</h2>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                               
            <p>Aquí s'afegiran lectures, activitats referències externes o bibliografia on l'estudiant, pugui ampliar l'aprenentatge si ho desitja</p>
        </div>
    </div>
    <!--=========== END META-INFO PANELS ================-->    
    
    <!--=========== BEGIN EMPTY PANEL ================-->    
    <div id="emptypanel-wrapper" class="right-position after-top-menu">
    </div>
    <!--=========== END EMPTY PANEL ================-->    
    
    <!--=========== BEGIN EMPTY MODAL WINDOW ================-->    
    <div id="modalWindow" class="iocModal hidden">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-selector-to-set-class="#modalWindow" data-class-to-set-class="iocModal hidden" aria-label="Close"><span aria-hidden="true">×</span></button>
            <h4 class="modal-title">Modal title</h4>
          </div>
          <div class="modal-body">
            
          </div>
          <div class="modal-footer">
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->
    <!--=========== END EMPTY MODAL WINDOW ================-->    

    <!--=========== BEGIN EMPTY LEFT COLUMN PANEL ================-->    
    <div id="leftColumnPanel" class="left-position column-panel after-top-menu">
    </div>
    <!--=========== END EMPTY LEFT COLUMN PANEL ================-->    

    <!--=========== BEGIN EMPTY HIDDEN PANEL ================-->    
    <div id="hiddenContent" class="hidden">
    </div>
    <!--=========== END EMPTY HIDDEN PANEL ================-->    

    <!--=========== BEGIN SCRIPTS ================-->    
    <!-- jQuery -->
    <script src="js/jquery.js"></script>
    <script src="js/jquery.easing.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- highlight.js plugin -->
    <script src="js/highlight.pack.js"></script>

    <!-- jssor.js plugin -->
    <script src="js/jssor.js"></script>
    <script src="js/jssor.slider.js"></script>
    
    <!-- to run jssor here-->
    <script src="js/jssorActivities.js"></script>

    <!-- slides functionality-->
    <script src="js/scrolling-slides.js"></script>

    <!-- specific functionality for IOC activities-->
    <script src="js/m03b2Activities.js"></script>

    <!-- specific functionality for this activ¡ty-->
    <script>
         $(document).ready(function(){
            var activityManager = new ActivityManager();
            
            activityManager.init("data/toReplace.json", "A501", false);
            var iocSlider = new IocSlider();
            activityManager.updateDisplayButtons(iocSlider);
        });
    </script>

</body>

</html>


