<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	 <meta name="author" content="Alícia Vila" >    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Activitat d'aprenentatge per introduir els conceptes de classe, biblioteques i tipus composts">
    
    
    <title>A501. Classes i biblioteques</title>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap.min.css" type="text/css"/>
<!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">-->
    <link rel="stylesheet" href="js/styles/default.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!-- Custom CSS -->
    <!--link to css slides-->
    <link href="css/m03b2Activities.css" rel="stylesheet">
    <link href="css/scrolling-slides.css" rel="stylesheet">
    <link href="css/highlightActivities.css" rel="stylesheet">
</head>
<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top">
 <span id="svgContainerId">
     <svg id="svgId" width="0" height="0" >
         <path
            id="pathId"
            d="M0 0"         
            stroke="#539ad7" 
            fill="none" 
            stroke-width="8px";
        />    
    </svg>
</span> 
<!-- Navigation hidden panel -->
    <aside>
        <a id="menu-toggle" href="#" class="btn btn-dark toggle after-top-menu" title="Informació"><i class="glyphicon glyphicon-info-sign"></i></a>
        <nav id="sidebar-wrapper" class=" after-top-menu">           
            <ul class="sidebar-nav">
                <a id="menu-close" href="#" class="btn btn-light pull-right toggle">
                    <i class="glyphicon glyphicon-remove-circle"></i>
                </a>
                <li class="sidebar-brand">
                    <a href="#slc-toStart"  onclick = '$("#menu-close").click();' >Inici activitat</a>
                </li>
                <li>
                    <a href="#" onclick = 'return $("#goals_info").togglePanelOnClick();'>Objectius</a>
                </li>
                <li>
                    <a href="#" onclick ='return $("#more_reinforcement").togglePanelOnClick(); '>Per reforçar</a>
                </li>
                <li>
                    <a href="#" onclick ='return $("#more_info").togglePanelOnClick(); '>Més informació per ampliar</a>
                </li>
            </ul>
        </nav>
        <nav id="bottom-wrapper">
             <!-- SCROLL PREVIOUS BUTTON -->
            <span id="prevArrow" class="btn arrownav previousSection" ></span>
            <!-- END SCROLL TOP BUTTON -->
             <!-- SCROLL NEXT BUTTON -->
            <span id="nextArrow" class="btn arrownav nextSection" ></span>
            <!-- END SCROLL TOP BUTTON -->
        </nav>        
    </aside>
    <!--=========== BEGIN HEADER SECTION ================-->
     <header id="header">
         <!-- BEGIN MENU -->
        <div class="menu_area">
            <nav class="navbar navbar-default navbar-fixed-top" role="navigation"> 
                <!-- LOGO -->
                <span class="navbar-brand navbar-left logo-nav"><img src="images/logo.png" title="{{$LOGO_TITLE}}" /></span>
                <div class="container-fluid">
                    <div class="navbar-header">
                    <!-- FOR MOBILE VIEW COLLAPSED BUTTON -->
                        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                          <span class="sr-only">Menú</span>
                          <span class="icon-bar"></span>
                          <span class="icon-bar"></span>
                          <span class="icon-bar"></span>
                        </button>
                    </div>
                    <div id="navbar" class="navbar-collapse collapse">
                        <ul id="top-menu" class="nav navbar-nav navbar-right main_nav">
                          <li class="active"><a href="#slc-toStart">Inici</a></li>
                          <li><a href="#slc-toKnow">Què cal saber</a></li> 
                          <li><a href="#slc-toDo">Què cal fer</a></li>
                          <li><a href="#slc-toDelivery">Lliurament</a></li> 
                          <li><a href="#slc-toContinue">Com continuar</a></li> 
                        </ul>           
                    </div>
                </div>     
            </nav>  
        </div>
        <!-- END MENU -->
    </header>
    <!--=========== END HEADER SECTION ================-->
    
    <!--=========== BEGIN MAIN SLIDER SECTION ================-->    
    <div id="mainSlider" class="iocMainPanel">
        <div class="slides">
            <!--=========== BEGIN SECTION toStart ================-->    
            <section id="slc-toStart" class="section">
                <div class="container">  <!--Bootstrap container-->
                    <!-- header -->            
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Inici activitat 501 - Classes, biblioteques i tipus composts</h2>
                             </div>
                        </div>
                    </div>
                    <!-- body -->            
                    <div class="row">
                        <div class="col-lg-12">
                             <div class=bodySlide>
                                 <p>Tal i com hem vist a l'aplicar el disseny descendent i l'ús de funcions, els programes resulten molt més llegibles, fàcils d'escalar i de localitzar errors si els dividim en parts, que no si fem l'aplicació, escrivint el codi tot seguit a la funció principal.</p>
				<p>No obstant, a mesura que el programa es fa més gran i complex, necessitem distribuir encara més la informació i, en ocasions, re-aprofitar parts de codi d'uns programes a altres. Així doncs, ara anem més enllà i el que farem serà agrupar diferents funcions o mètodes que facin referència a un mateix tema en el que se sol anomenar <b>mòduls</b>. 
				A JAVA aquests mòduls són equivalents al concepte de <b>classe</b>. Per tant, el que definirem a partir d'ara serà un programa dividit en diverses classes interrelacionades i organitzades en diferents fitxers.</p>
				<p>Per últim, també veurem que en moltes ocasions els tipus de dades que coneixem fins ara (variables simples, arrays,...) no són suficients per representar les dades d'un programa. 
				Per això, definirem el que s'anomenen <b>tipus composts</b> com una agrupació de dades de diferents tipus i veurem com es gestionen en JAVA. 
                                 <p>Aquesta activitat us permetrà aprendre com implementar i fer servir <em>classes, biblioteques i tipus composts</em>, de manera que us serveixi de pràctica per posteriors implementacions del projecte.</p>
                                 <p>En primer lloc haureu de llegir l'apartat <em><a href="#slc-toKnow">Què cal saber</a></em>. Allà, se us explicaran els coneixements bàsics que necessitareu per dur a tyerme l'activitat. </p>
                                 <p>Després caldrà que feu els exercicis que se us demana a l'apartat <em><a href="#slc-toDo">Què cal fer</a></em>. Es tracta d'un conjunt d'exercicis que us ajudaran a consolidar l'aprenentatge dels conceptes explicats.</p>
                                 <p>A l'apartat <em><a href="#slc-toDelivery">Lliurament</a></em>, se us dóna la informació bàsica per poder fer el lliurament de l'activitat. No us oblideu de llegir l'apartat i seguir les seves indicacions</p> 
                                 <p>Finalment, a l'apartat <em><a href="#slc-toContinue">Com continuar</a></em>, us redirigirà a la següent activitat. </p> 
                             </div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toStart ================-->    

            <!--=========== BEGIN SECTION  toknow ================-->    
            <section id="slc-toKnow" class="vsections">
                <!--=========== BEGIN SUBSECTION Definició classe ================-->    
                <section id="slc-toKnow10" class=" section">
                    <div class="container">  <!--Bootstrap container-->
                        <!-- header -->            
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Què és una classe?</h3>
                                 </div>
                            </div>
                        </div>
                        <!-- body -->            
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Com hem vist fins ara, el disseny descendent ens ha permès tenir el codi d'un programa ben endreçat.
                                    No obstant, això no serà suficient quan el programa creix en mida i complexitat, ja que ens trobarem amb un programa amb molts mètodes que, igualment, ens generarà un fitxer molt llarg de llegir i localitzar errors.
                                    La solució a aquest problema és desenvolupar el codi dividint-lo en components més fàcils de modificar que s'anomenen <b>mòduls</b>, 
                                    on cadascun d'ells agrupa un conjunt de funcions o mètodes que realitzen tasques relacionades.
                                    Arribats a aquest punt, cal recordar que hem de defugir dels programes monolítics, on tot el codi es centra en un únic mòdul. 
                                     </p>
                                    <p>En general, en un programa modular cada mòdul es representa amb un fitxer de codi font diferent que facilita, entre altres, el reaprofitament. 
                                    En el cas de JAVA, un mòdul equival al que anomenem <b>classe</b> i així, un programa modular està compost pel conjunt de diverses classes, en lloc de només una, i cada classe estaria implementada en un fitxer diferent.</p>
                                    <p>L'ús que fem de les classes és:</p>
				<ul>
					<li><b>Programa en JAVA</b>: Els fitxers dels programes, pròpiament, són classes (<code>public class…</code>). En aplicar disseny descendent, el seu codi queda distribuït en un mètode principal (<code>main</code>), que indica el seu punt d’inici, junt amb diferents mètodes addicionals que poden ser cridats directament.</li>
					<li><b>Repositori de funcions o biblioteques</b>: Correspondrien a un conjunt de funcions definides per l'usuari o bé pel propi llenguatge JAVA. Per exemple, la classe <code>Scanner</code>, que ofereix un repertori de mètodes per controlar la lectura de dades des del teclat (<code>nextLine()</code>, <code>nextInt()</code>, <code>hasNextFloat()</code>, etc.). </li>
					<li><b>Tipus compost</b>: Aquest mateix terme s’ha usat com a sinònim de tipus compost. Per exemple, la classe <code>String</code>, utilitzada per referir-se a cadenes de text dins de JAVA. Els tipus compostos de JAVA permeten manipular dades complexes mitjançant la crida de mètodes (<code>charAt(…)</code>,<code>indexof(…)</code>, etc.).</li>
				</ul>
				<p>Cal destacar que els tres casos anteriors tenen característiques comunes, doncs tots ells són classes amb variables o mètodes. La diferència està en el context en el que s'usen i la manera d'invocar el seu contingut.
				El cas de biblioteques i tipus composts, els tractarem en apartats posteriors.</p>
				<p>Per exemple, tot i que no ens cal conèixer el codi sencer, la classe <code>Scanner</code> ha estat desenvolupada dins d’un fitxer anomenat <code>Scanner.java</code>, i una part del seu codi és:</p>
				<pre><code class="java">
public class Scanner {
    //Altres declaracions (constants, vars. globals...) ...
	
	public String nextLine() {
		//Codi del mètode ...
	}
	
	public int nextInt() {
		//Codi del mètode ...
	}
	
	//Altres mètodes ...
}
				</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION definició classe  ================-->    
                
                <!--=========== BEGIN SUBSECTION programa modular ================-->    
                <section id="slc-toKnow20" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Estructura d'un programa modular en JAVA</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Per a realitzar un programa modular en JAVA cal definir un criteri per distribuir els mètodes en diferents classes i, aquestes, en diferents fitxers. 
                                    És important tenir en compte que sempre ha d'haver-hi una classe principal (<code>Main class</code>) que és la que disposa d'un mètode principal declarat al seu codi i que suposa el punt d'inici de l'execució del programa.</p>
				<p>Per tal d'executar un programa modular en JAVA, només cal executar aquesta classe principal. A partir d’aquí, l’execució de les diferents instruccions segueix el flux de control habitual (figura 1), partint del mètode principal d’aquesta classe.</p>
				<figure id ="figura_flux" class="left">
                    <img width="464" src="images/activities/ic10m3u5_02.png" alt="flux de control en un programa amb classes addicionals">
                    <figcaption style="width: 510px; max-width: 75%;">
                        <span class="figuretitle">figura </span> Flux de control en un programa modular.                               
                    </figcaption>
                </figure>
				<p>Cal destacar, que a la classe principal hi ha d’haver tant el mètode <code>main</code> com el mètode <code>inici</code>. Cap dels dos és necessari a la resta de classes.</p>
				<p>En un programa modular, podem definir <b>classes addicionals</b> (que no són la classe principal) nosaltres mateix o bé altres desenvolupadors per requeriments del programa. 
				En tots els casos, les classes estaran declarades i codificades en fitxers <em>.java</em> per separat. L'objectiu principal que tindran aquests tipus de classes seran la de repositoris de mètodes.</p>
				<p>Abans de començar a implementar les classes, cal raonar en quins casos ens pot interessar dividir els mètodes d’un programa entre diferents classes. Entre altres, podeu pensar en els següents:</p>
				<ul>
					<li>Quan tenim molts mètodes</li>
					<li>Quan tenim mètodes que fan referència a un mateix concepte</li>
					<li>Quan tenim mètodes que podríem reaprofitar a altres programes</li>
				</ul>
               <p>Un exemple de programa fent servir aquestes classes addicionals o creades pel propi usuari, seria el següent: </p>                                 
   				<pre><code class="java">
public class RegistreNotes {

	public static void main(String[] args) {
		RegistreNotes programa = new RegistreNotes();
		programa.inici();
	}

	public void inici() {
		double[] notes = {2.0, 5.5, 7.25, 3.0, 9.5, 8.25, 7.0, 7.5};

	//Per cridar els mètodes cal inicialitzar la classe que els conté				
	CalculsArrayReals calculador = new CalculsArrayReals();

    //Un cop fet, cal cridar-los usant com a prefix l'identificador
	double max = calculador.calcularMaxim(notes);
	double min = calculador.calcularMinim(notes);
	double mitjana = calculador.calcularMitjana(notes);
	System.out.println("La nota màxima és " + max + ".");
	System.out.println("La nota mínima és " + min + ".");
	System.out.println("La mitjana de les notes és " + mitjana + ".");
	}
}
            </code></pre>
				<p>On la classe <em>CalculsArrayReals()</em> està definida en altre fitxer:</p>
				<pre><code class="java">
public class CalculsArrayReals {
	public double calcularMaxim(double[] array) {
		double max = array[0];
		for (int i = 1; i &lt; array.length; i++) {
			if (max &lt; array[i]) {
				max = array[i];
			}
		}
    	return max;
	}
	public double calcularMinim(double[] array) {
		double min = array[0];
		for (int i = 1; i &lt; array.length; i++) {
    		if (min &gt; array[i]) {
        		min = array[i];
    		}
		}
		return min;
	}
	public double calcularMitjana(double[] array) {
		double suma = 0;
		for (int i = 0; i &lt; array.length; i++) {
    		suma = suma + array[i];
		}
    	return suma/array.length;
	}
}
				</code></pre>
				<p>És molt important tenir en compte com es realitza la <b>invocació o crida de mètodes</b> que no estan implementats en el mateix fitxer. 
				Primer cal un pas previ d’inicialització, a partir del qual es permet la invocació dels mètodes externs. 
				En dur a terme aquest procés, s’assigna un identificador a partir del qual és possible invocar els mètodes d’aquella classe, usant-lo com a prefix a la invocació. 
				Sense aquest pas previ, és impossible invocar mètodes escrits a altres classes. La sintaxi per fer-ho és la següent:</p>
					<pre><code class="java">                                      
NomClasse identificador = new NomClasse();
identificador.nomMetode(parametres);</code></pre>
					
					<p>En nomenclatura JAVA, el procés d’inicialització s’anomena formalment <b>instanciació</b> de la classe.
               El comportament de la invocació del mètode és idèntica a quan es fa sobre un mètode escrit a la mateixa classe. 
               Només canvia la sintaxi, ja que es requereix aquest prefix producte de la inicialització. 
               Cal dir que, donades diverses invocacions a mètodes d’una mateixa classe externa, només és necessari fer la inicialització una única vegada. 
               L’àmbit i la validesa de l’identificador és el mateix que una variable.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION programa modular ================-->    
                
                <!--=========== BEGIN SUBSECTION Biblioteques de JAVA: API ================-->    
                <section id="slc-toKnow40" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >L'API de JAVA</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Per crear programes modulars no és necessari crear cadascun dels mòduls que formen part del programa. Sovint els llenguatges de programació incorporen biblioteques de mòduls auxiliars que ja han estat completament desenvolupats. Aquests mòduls auxiliars ofereixen funcionalitats que van més enllà del que permet la seva sintaxi estrictament o incorporant l’opció d’executar blocs de codi que resolen tasques que es consideren de propòsit general i que poden ser d’utilitat en una àmplia gamma de programes.</p>
                                    <div class="iocnoteOpener">
                                        <a href='#' role="button" data-toggle='tooltip' role= "tooltip" title="Què són els paquets o packages?" data-target="queSonPaquets" data-note-by="paquets">
                                            <img src="images/nota2.png" alt="nota sobre paquets" style="width: 100%;"/>
                                        </a>
                                        
                                            <span id="queSonPaquets" class="iocnoteSlidePane toggle-off">
                                                Els paquets organitzen les classes de <em>Java</em> de forma equivalent a com els directoris organitzen el fitxers d'un sistema informàtic. En aquest sentit, direm que els paquets poden contenir classes i també altres paquest. De forma semblant als fitxers, les classes es poden anomenar de forma absoluta (nom complert), indicant tota la jerarquia de paquest on està continguda o bé de forma relativa (nom curt), indicant només el nom de la classe. Per poder fer servir una classe d'un biblioteca de tercers cal importar-la indicant el seu nom complert (forma absoluta). Un cop importada es pot fer servir el nom curt (forma relativa). A diferencia dels directoris del sistema de fitxers, els paquets de Java se separen entre ells fent servir <em>un punt </em>com a símbol separador.   
                                            </span>
                                    </div>
                                    <p>En el cas del llenguatge Java, el seu kit de desenvolupament (JDK) incorpora un quantiós repositori de classes, organitzats en diferents <em><span id=paquets>paquets</span> (packages)</em>  d’acord a la seva temàtica, que poden ser accedides lliurement en realitzar qualsevol programa. Aquest repositori és el que s’anomena l’<b>API</b> de JAVA. </p>
                                    <p>La documentació de l’API de JAVA ofereix un enorme repertori de classes que contenen mètodes amb funcionalitats molt diverses.</p>
                                    <p>Els <em>packages</em> que contenen les classes més usuals són:
												<ul>
													<li><code>java.lang</code>: conté totes les classes vinculades a operacions essencials dels tipus de dades del llenguatge.</li>
													<li><code>java.util</code>: una mena de calaix de sastre amb classes de propòsit general.</li>
													<li><code>java.io</code>: conté totes les classes vinculades a entrada / sortida (tractament de fitxers).</li>
													<li><code>javax.swing</code>: conté les classes bàsiques vinculades a la creació d’interfícies gràfiques.</li>
												</ul>
												<p>L’avantatge de conèixer aquests paquets és que, com que aquestes classes ja estan creades i incorporades com a part del llenguatge, si en trobeu una que ja faci la feina requerida, us estalviareu haver d’escriure parts de codi font del programa.</p>
												<p>Per poder usar qualsevol classe d’entre les definides a l’API de JAVA cal seguir exactament les mateixes passes que per a una classe realitzada per vosaltres, però dins un <em>package</em> diferent: importar-la a l’inici del codi font i inicialitzar-la. 
												Un cop fet, la sintaxi per invocar els seus mètodes és exactament la mateixa. Aquest procés només té una particularitat molt especial, i és que no cal disposar del codi font de la classe en qüestió. En estar incorporada dins el JDK, Java ja sap localitzar el seu codi automàticament.</p>
												<p>Per exemple, suposeu que heu de fer un programa que ha de generar dos valors reals a l’atzar, entre 0 i 100, i voleu que els mostri per pantalla. 
												D’entrada, resoldre aquest problema suposaria haver de crear dins del codi font algun mètode que generés aquests valors reals aleatoris, donat que existeix una classe anomenada Random ja incorporada a l’API de Java, la podem fem servir.
												Cercant-la a la documentació de l’API de Java, es veu que forma part del <code>package java.util</code>. A continuació veiem com es pot fer servir aquesta classe:</p>
                                    
                                 <pre><code class="java">
package ioc.m03.uf2.funcions.a501;
//Importació de la classe, en estar en un altre package
import java.util.Random;
public class RealsAleatoris {
	public static void main(String[] args) {
		RealsAleatoris programa = new RealsAleatoris();
			programa.inici();
							}
	public void inici() {
			//Cal generar un valor a l'atzar
			//Cal generar-ne l'altre
			//Mostrar-los
								}
						}
                                    </code></pre>
                                    <p> Com forma part de l’API de Java, l’ús de la classe Random no implica la incorporació de cap altre fitxer de codi font.
                                     Un cop ja està tot llest per usar-la, caldrà mirar quins mètodes ofereix per generar reals a l’atzar.</p>   
                                     <p>Cal destacar que el procés tot just descrit ja l’heu usat anteriorment en diverses ocasions, per exemple, cada cop que us calia llegir dades pel teclat i heu usat <em>Scanner</em>. 
                                     Si mireu la documentació de l’API de JAVA, trobareu aquesta classe dins el mateix <code>package java.util</code>.</p>     
                                     <p>Algunes classes de Java tenen una particularitat, i és que a l’hora d’inicialitzar-les cal especificar un conjunt d’informació addicional en forma de <b>paràmetres</b>.                                      
												 <p>Fins al moment, s’ha dit que per inicialitzar una classe per tal de poder invocar els mètodes que ofereix calia fer:</p>
												  <pre><code class="java">
NomClasse identificador = new NomClasse();
												  </code></pre>   
												 <p>Però hi ha casos en què, per inicialitzar correctament la classe, cal afegir un conjunt de valors entre els parèntesis, de manera idèntica a com es faria en invocar un mètode. Si no es posen aquests paràmetres quan pertoca, hi haurà un error de compilació.</p>                       
													<pre><code class="java">
NomClasse identificador = new NomClasse(paràmetres);
												  </code></pre>   
												  <p>Per exemple, la classe <em>Scanner</em>. Per inicialitzar-la correctament li cal un paràmetre indicant quin sistema d’entrada ha de processar:</p>
												  <pre><code class="java">
Scanner lector = new Scanner(System.in);
												  </code></pre>   
												  <p>Per veure si cal o no incloure un paràmetre en inicialitzar una classe, caldrà cercar-lo a la seva documentació. Concretament, a l’apartat anomenat resum de constructors (<em>Constructor Summary</em>) indica la sintaxi de la part dreta de la inicialització.</p>                       
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Biblioteques de JAVA: API ================-->        

                <!--=========== BEGIN SUBSECTION Mètodes estàtics ================-->    
                <section id="slc-toKnow41" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Mètodes estàtics</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>En general, per poder invocar mètodes d’una classe cal inicialitzar-la prèviament fent servir la sentència <em>new</em>. 
                                    Ara bé, d’entre tots els mètodes proporcionats dins de les classes disponibles a l’API de Java, hi ha un petit subconjunt que s'anomenen <b>mètodes estàtics</b> que poden ser invocats sense haver d' inicialitzar la seva classe. S’identifiquen perquè a la documentació apareixen marcats amb la paraula clau <code>static</code>. </p>
												<p>Per invocar aquests mètodes, la sintaxi correcta és posar com a prefix el nom de la classe directament. A part d’això, el seu comportament és idèntic a qualsevol altre mètode. És a dir: </p>                                    
                                    <pre><code class="java">
NomClasse.nomMetode(paràmetres);
                                    </code></pre>   
                                    <p>Per exemple, donat el mètode estàtic <code>sqrt</code> definit a la classe <code>Math</code>: </p>
                                       <pre><code class="java">
double resultat = Math.sqrt(36);
                                    </code></pre> 
                                    <p>A continuació veurem els mètodes estàtics d'algunes de les classes més importants:</p>
                                    <ul>
												<li><b>La classe Math: </b>Pertany al <em>package</em> <code>java.lang</code>, i per tant pot ser usada sense haver d’importar-la. 
												Ofereix un ventall de mètodes estàtics per realitzar operacions matemàtiques avançades com: arrodoniment de valors(<code>round(valor)</code>), potència(<code>pow(base, exponent)</code>), arrel quadrada (<code>sqrt(valor)</code>), màxims i mínims (<code>max(a, b)</code>, <code>min(a, b)</code>),...Per exemple:
 <pre><code class="java">												
package ioc.m03.uf2.funcions.a501;
import java.util.Random;

public class ArrodonirReal {
    public static void main(String[] args) {
        ArrodonirReal programa = new ArrodonirReal();
        programa.inici();
    }
    public void inici() {
        //Inicialització de Random
        Random rnd = new Random();
        //Ús per generar un real entre 0 i 1
        double valor = rnd.nextDouble();
        System.out.println("El valor real generat és " + valor);
        //Ús del mètode estàtic. No cal inicialitzar res, es pot usar directament.
        //No cal importar-la, ja que pertany a java.lang
        long arrodonit = Math.round(valor);
        System.out.println("El valor arrodonit és " + arrodonit);
    }
}
</code></pre>  
												</li> 
												<li><b>La classe Array:</b>Pertany al <em>package</em> <code>java.util</code> (com Random i Scanner). 
												Ofereix mètodes estàtics per fer operacions típiques amb arrays (ordenacions(<code>sort(array)</code>), còpies(<code>copyOfRange(array, posInici, posFi)</code>) , cerques(<code>binarySearch(array, clau)</code>), igualtats (<code>equals(array1, array2)</code>), conversió a text (<code>toString(array)</code>), etc.). 
												Per usar-los cal tenir present que alguns d’aquests manipulen els paràmetres d’entrada de tipus compost, en aquest cas arrays. Per tant, en finalitzar la invocació, l’array original haurà canviat.
												A continuació podem veure un exemple:
<pre><code class="java">												
package ioc.m03.uf2.funcions.a501
import java.util.Arrays;

public class OrdenaArrayText {
    public static void main (String[] args) {
        OrdenaArrayText programa = new OrdenaArrayText();
        programa.inici();
    }
    public void inici() {
        String[] array = {"Un", "Dos", "Tres", "Quatre", "Cinc"};
        Arrays.sort(array);
        System.out.println("Els elements ordenats són:");
        for (int i = 0; i < array.length; i++) {
            System.out.println(array[i]);
        }
    }
}	
</code></pre> 
											
												</li>                                 
                                    </ul>      
                                    <p>Hi ha moltes més classes que podeu consultar per tal de conèixer com funcionen aquests mètodes estàtics. </p>              
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Mètodes estàtics ================-->       
                
                <!--=========== BEGIN SUBSECTION Estructures de dades: Tipus composts ================-->    
                <section id="slc-toKnow50" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Estructura de dades: Tipus composts</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                <p>Com ja heu anat veient amb l'experiència que porteu programant, quan implementem una aplicació gran, la quantitat de dades es multiplica. En aquests casos, l'ús de variables globals està totalment desaconsellat perquè treballar amb moltes variables a l'hora pot comportar molts errors, a més de la poca eficiència que suposa definir un nombre desmesurat de variables.</p>
                                <p>Malgrat tot, l'alternativa de treballar amb variables locals no és menys arriscada ja que sovint, en els processos de nivell alt podem arribar a necessitar moltes variables i pot ser realment tediós haver-les de passar per paràmetres i per descomptat, en el fons no deixa de ser també una font d'errors.</p>
                                <p>Sortosament, ja hem vist que podem fer servir arrays per agrupar dades. Ara bé, no totes les dades es poden emmagatzemar en arrays, i ni que així fos, una aplicació gran podria necessitar també un nombre gran d'arrays. Caldrà doncs, cercar altra solució que ens permeti agrupar dades amb independència del seu tipus. </p>
                                <p>La majoria de llenguatges de programació permeten la creació d'<b>estructures de dades</b> per poder pal·liar el problema de la disgregació de dades. Es tracta d'una forma d'agrupar dades de diferent tipus fent servir una única variable.</p>
                                <p>L'estructura de dades ideal per aplicacions grans ja que permet organitzar les dades de forma jeràrquica i obtenir subconjunts de dades coherents escollint el tros adequat de la jerarquia. Quan parlem d'estructura jeràrquica ens referim a algun sistema en que unes dades s'englobin dins d'altres formant un arbre. Per tal que això sigui possible, cal procurar agrupar les dades relacionades sota un mateix concepte.</p>
                                <p>Seleccionar la jerarquia correcta no sempre es senzill. Si l'aplicació es petita, és possible agrupar totes les dades en un sol bloc, o crear un número reduït de blocs independents. Internament, cada bloc tindrà un un conjunt de dades de diversos tipus (enters, cadenes, arrays,...) però organitzades de forma que siguin conceptualment coherents.</p>
												<p class="iocimportant">Les estructures de dades són organitzacions més o menys complexes de dades, de tal forma que la seva organització ens configura un valor extra que ens ajuda a interpretar la informació que representen. Per exemple, hem de considerar una estructura de dades el conjunt de valors que poden identificar i representar una persona. Per exemple el seu nom, la seva edat, el seu DNI, les titulacions que posseeix, els treballs que ha realitzat, etc.</p>
												<p>Els llenguatges de programació donen suport a les estructures de dades per mitjà dels tipus compostos de dades i concretament, el llenguatge JAVA, fa servir classes per definir els seus tipus de dades compostos.</p>
												<p class="iocimportant">Els tipus de dades compostos (classe en el llenguatge JAVA) permeten definir com s'identifiquen i organitzen els valors entre sí. Com identificadors usarem noms conceptuals que ens ajudin a interpretar el que representen.</p>
												<p>Per exemple, si haguéssim d'implementar una calculadora que hagués de fer les 4 operacions bàsiques entre dos números qualsevol, el tipus compost a fer servir podria ser:</p>
												                                    
                                    <div class="iocexample">
                                         
                                    <pre><code class="java">
package ioc.m03.uf2.funcions.a501;
public class DadesCalculadora {
    double operador1;
    double operador2;
    char operacio;    
    double resultat;
}
                                         </code></pre>
                                    </div>
                                    <figure id ="figura_instanciacio" class="left">
                                        <img width="464" src="images/activities/tipusCompostInstancia.png" alt="instanciació de tipus compostos">
                                        <figcaption style="width: 510px; max-width: 75%;">
                                            <span class="figuretitle">figura </span> Instanciació d'un tipus compost.                               
                                        </figcaption>
                                    </figure>
                                    <p>Fixeu-vos que els tipus compostos no són les dades pròpiament. En realitat els tipus compostos són el que defineix quina forma han de tenir les dades, de quins tipus ha de ser, quins seran els identificadors dels diferents valors i quina la organització interna. Ara bé, i les dades? com hi afegim les dades? Abans d'explicar-ho m'agradaria remarcar que les dades no s'emmagatzemen a l'estructura. El llenguatges de programació només poden emmagatzemar dades a la memòria i és allà on aniran a parar les dades. Així doncs, per a què serveixen aleshores els tipus compostos? Doncs l'explicació que més s'hi aproxima és que actuen de plantilla. Així, els tipus compostos emmotllen la memòria per poder-hi emmagatzemar dades en la forma definida en cada tipus compost. En l'argot dels llenguatges de desenvolupament, en comptes de parlar d'emmotllar, es parla d'instanciar (figura 1). De fet, les dades de la memòria són instancies d'algun tipus de dades (siguin o no compostos).</p>
<p>Cada tipus compost pot instanciar múltiples dades a la memòria de forma simultània. Cada dada manté els seus propis valors.
A la pràctica, la instanciació es fa sobre una variable i es fa servir la paraula clau <em>new</em> seguida del tipus compost a instanciar amb els parèntesis d'execució:</p>
                                         <pre><code class="java">
DadesCalculadora operacio1 = new DadesCalculadora();
DadesCalculadora operacio2 = new DadesCalculadora();
                                         </code></pre>
                                    
                                    <p> A partir d'una instancia de tipus compost (variable), podem accedir als seus elements per modificar o obtenir el seu valor escrivint després del nom de la variable, un punt seguit del nom de l'element. Exemple:</p>
                                         <pre><code class="java">
operacio1.operador1 = 5;
operacio1.operador2 = 3;
operacio1.operacio = '+';
...
if(operacio1.operacio == '+'){
    operacio1.resultat = operacio1.operador1 + operacio1.operador2;
} 
                                         </code></pre>
                                    <p>En el llenguatge JAVA no és possible donar valors a una estructura si no s'ha creat la instancia del seu tipus compost. Si ho féssim obtindríem un error:</p>
                                         <pre><code class="java">
DadesCalculadora operacio2;
operacio1.operador1 = 7; //Això dona error perquè no s'ha instanciat la variable: operacio2 = new DadesCalculadora() 
												</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Estructures de dades: Tipus composts ================-->  
            </section>                             
            <!--=========== END SECTION toknow ================-->    

            <!--=========== BEGIN SECTION toDo ================-->    
            <section id="slc-toDo" class="vsections">
                <!--=========== BEGIN SUBSECTION Descripció dels exercicis ================-->    
                <section id="slc-toDo10" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Descripció general</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>En aquesta secció se us proposa fer 2 tasques per debatre al <span class="forumDeDiscussio"></span>  , 
                                    que pretenen fer-vos reflexionar sobre els conceptes apresos en relació a les classes, biblioteques i tipus composts. Cada debat es troba en un apartat diferent. Passeu al següent per iniciar el primer debat.
                                     </p>
												         
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Descripció dels exercicis  ================-->    
                
  					<!--=========== BEGIN SUBSECTION Debat 1 ================-->    
                <section id="slc-discussion11" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer? Classes, biblioteques i tipus composts</h2>
                                     <h3> Debat 1. La reutilització </h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p> Segurament, un dels criteris que més avantatge ha suposat per el desenvolupament de programari, ha estat la reutilització del codi, perquè així s'aconsegueix codificar més ràpidament i es cometent molts menys erros. És evident que per poder reutilitzar codi en diferents contextos (diferents parts d'un programa, diferents aplicacions, etc.), cal separar aquelles parts que es poden reutilitzar, de les que difícilment podran reutilitzar-se a cap altra context. </p>
                                    <p>Ara bé, cal assenyalar que crear biblioteques de funcions reutilitzables no és trivial, ja que requereix d'un esforç d'abstracció important per tal d'aïllar el que és inevitablement específic d'una aplicació, del que es pot generalitzar afegint-hi paràmetres. Si no hi parem gaire atenció, tindrem tendència a barrejar-ho tot i ens resultarà impossible trobar entre el nostre codi cap funció genèrica.</p>
                                    <p>Per exemple, és habitual, en programadors poc experimentats, barrejar en una mateixa funció la demanda de dades a l'usuari, el tractament d'aquestes i la mostra del resultat. Penseu però que generalment, les demandes de dades a l'usuari i la mostra de resultats per pantalla, són realment processos molt específics i lligats  a l'aplicació en la que s'han desenvolupat. Això els converteix realment en processos difícilment reutilitzables. Per contra, els tractaments que reben les dades solen ser processos altament reutilitzables si aconseguim parametritzar-los amb una mica d'habilitat.</p>
                                    <p>A continuació se us presenta la funció <em>trobarTemperaturaMinima</em>, la qual permet trobar el valor mínim d'un conjunt de temperatures introduïdes per l'usuari. Fixeu-vos però que la funció no compleix els requisits indicats per poder ser considerada reutilitzable, ja que només es podria fer servir en algun context que calgués trobar la temperatura mínima d'una conjunt de temperatures donades per l'usuari. És a dir exclusivament l'actual!</p>
                                    <p>Tal com està codificada la funció no serviria per trobar les temperatures mínimes emmagatzemades en el disc dur, en comptes de demanar-les a l'usuari, ni molt menys per trobar el valor mínim de quelcom que no fossin temperatures, ni permetria emmagatzemar el valor mínim en el disc dur, o enviar-lo a un servidor, en comptes de mostrar-lo per pantalla, ja que la petició de dades, el càlcul del resultat i la mostra d'aquest formen un tot indivisible.</p>
                                    <pre><code class="java linenumbers">
public void trobarTemperaturaMinima(){
float[] temperatures;
int posMin;            
System.out.println("Quantes temperatures vols omplir?");
int mida = scanner.nextInt();
temperatures = new float[mida];
            
System.out.println("Entra el valor de les temperatures");
for(int i=0; i&lt;temperatures.length; i++){
System.out.println("Temperatura " + (i+1) + ": ");
temperatures[i]=scanner.nextFloat();
     }

       posMin=0;
            for(int i=1; i&lt;temperatures.length; i++){
                if(temperatures[posMin]&gt;temperatures[i]){
                    posMin=i;
                }
            }
            System.out.println("La Temperatura mínima és: " +  temperatures[posMin]);
        }
                                     </code></pre>
                                     <p>Es demana que recodifiqueu la funció, dividint-la, de manera que agrupeu una part del codi en almenys una funció realment reutilitzable, poden ser més si ho creieu oportú (consulteu la pista 2 si us interessa). Acompanyeu la codificació amb un raonament que justifiqui la divisió realitzada i pengeu-ho al <span class="forumDeDiscussio">forum de discussió</span>.</p>
                                    <p>També es demana que reflexioneu en el fòrum, si les noves funcions substituirien totalment la funció <em>trobarTemperaturaMinima</em> de manera que caldria eliminar-la del codi, o si per contra, les noves funcions, necessitarien encara de la funció <em>trobarTemperaturaMinima</em> adaptada a la crida d'aquestes.</p>
                                     <p>Finalment se us demana que escolliu el codi que algun dels vostres companys hagi penjat en el fòrum. Intenteu que sigui ben diferent al que vosaltres hagueu penjat. Compareu ambdós codis (el vostre i el del company escollit) seguint les indicacions de l'informe de comparació d'aquesta activitat. Reserveu l'informe de comparació per fer el lliurament a la bústia de lliuraments.</p>

                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion11" 
                                            data-selector-clue="#slc-discussion11-clue1">
                                        Pista 1
                                    </button>                                        
                                    <div id="slc-discussion11-clue1" class="iocClue hidden">
                                        <h2>Pista 1</h2>
                                        <p>Identifica la part del codi destinada a preguntar a l'usuari els valors de les temperatures, la part del codi destinada a mostrar el resultat i la part del codi destinada a cercar el valor mínim.</p>
                                        <p>Creus que hi ha diferencia entre cercar la temperatura mínima, la nota mínima, el menor temps, o el menor consum de carburant? Si no hi ha diferencia, podríem idear una un procés comú a tots ells. Quines dades necessitaria el procés? Quin seria el resultat del procés?</p>
                                    </div>                                    
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion11" 
                                            data-selector-clue="#slc-discussion11-clue2">
                                        Pista 2
                                    </button>                                        
                                    <div id="slc-discussion11-clue2" class="iocClue hidden">
                                        <h2>Pista 2</h2>
                                        <p>Una altre aspecte a destacar de la reutilització i les biblioteques de funcions consisteix en l'aïllament o encapsulació de blocs de codi intercanviables, de manera que sigui possible evitar que una modificació pugui produir errades en multitud de llocs del programa.</p>
                                        <p>Per exemple en el cas que ens ocupa la font que proporciona els valors de les temperatures a tractat, és el mateix usuari, però no té perquè ser sempre així. De fet, sembla lògic que els valors de les temperatures puguin estar emmagatzemats en un fitxer o arribar a través d'Internet, etc. Si disposéssim d'una funció anomenada <em>obtenirValorsTemperatura</em> que retorni el conjunt de temperatures a analitzar amb independència d'on s'aconsegueixin, seria possible alternar la font origen de les dades sense tocar més codi que el que es troba dins d'aquesta funció, de manera que asseguraríem que la resta de programa funcionaria perfectament sigui quina sigui la funció d'obtenir les temperatures que finalment utilitzéssim.</p>
                                    </div>                                    
                                 </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Debat 1 ================-->     

  					<!--=========== BEGIN SUBSECTION Debat 2 ================-->    
                <section id="slc-discussion20" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer? Classes, biblioteques i tipus composts</h2>
                                     <h3> Tasca 2. Biblioteques</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Aquí us proposem crear una biblioteca específica de tractament de cadenes que afegeixi funcionalitat extra a les funcions pròpies de la classe String. A fi de practicar el que heu anat descobrint, en aquesta activitat, us proposem la creació d'una biblioteca d'utilitats que no precisi la inicialització de la classe. És a dir que faci servir mètodes estàtics.</p>
                                    <p>Concretament us proposem que codifiqueu 3 funcions en una classe anomenada Strings:</p>
                                    <ul>
                                        <li>La funció <em>retallarFinsMida</em>. Aquesta funció està pensada per evitar que una cadena sobrepassi una mida màxima. La funció rep una cadena de caràcters i un valor numèric que representa la mida màxima de la cadena a partir de la qual començarà a retallar-se. Si la cadena passada no sobrepassa la mida màxima, la funció retornarà exactament la mateixa cadena rebuda. Per contra, si la cadena sobrepassa la mida, es retallarà de manera que en concatenar-hi pres punts esdevingui una cadena de exactament la mida màxima. Així imaginem que fem la següent crida:
                                        <pre><code class="java">
String retorn = Strings.retallarFinsMida("Cadena llarga que caldrà retallar", 17);
                                        </code></pre>
                                        La variable <em>retorn</em> valdrà "<em><code>Cadena llarga ...</code></em>" que és el valor retornat per la funció. És a dir, la cadena original retallada a 14 caràcters + els 3 punts finals.
                                        </li>
                                        <li><p>La funció <em>farcirFinsMida</em>, la qual rebrà també una cadena de caràcter i un valor numèric que indicarà la mida mínima a la que ha de retornar la cadena original. És a dir si la cadena fa una mida superior o igual a la mínima es retronarà exactament el valor original, però si no arriba a la mida mínima caldrà afegir caràcters [ESPAI] per la dreta de la cadena fins aconseguir una cadena de la mida mínima. Per exemple:</p>
                                        <pre><code class="java">
String retorn = Strings.farcirFinsMida("Curt", 10);
                                        </code></pre>
                                        <p>fa que s'emmagatzemi a la variable <em>retorn</em> el valor "<em><code>Curt&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code></em>". És a dir, la cadena original + 6 espais.</p>
                                        <p>Opcionalment i de forma totalment voluntària, podeu incorporar més paràmetres a la funció per tal de poder escollir el caràcter de farciment i també la localització del mateix, de manera que sigui possible decidir quin caràcter es farà servir de farciment i si aquest es farà pel cantó esquerra o pel cantó dret de la cadena original.</p>
                                        </li>
                                        <li>La funció <em>midaExacta</em> que rebrà una cadena i un valor numèric i retornarà una cadena d'exactament la mida indicada pel valor del segon paràmetre. En cas que la cadena tingui la mida indicada es retornarà exactament el valor original, si fos més petita es farciria amb tants caràcters com fos necessari per aconseguir la mida indicada. Per contra si la cadena sobrepassés la mida desitjada, aquesta es retornaria retallada i es concatenarien 3 punts de forma que la mida resultant fos la mida exacta.   
                                        </li>
                                    </ul>
                                    <p>A més de les funcions de la classe Strings, feu també una classe anomenada Tasca2 que us permeti provar el bon funcionament de les tres funcions anteriors.</p>
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion20" 
                                            data-selector-clue="#slc-discussion20-clue1">
                                        Pista 1
                                    </button>                                        
                                    <div id="slc-discussion20-clue1" class="iocClue hidden">
                                        <h2>Pista 1</h2>
                                        <p>Recordeu que en la operació + sobre cadenes de caràcters permet concatenar qualsevol valor de qualsevol tipus. Només cal que el primer element de la suma sigui una cadena per tal que el llenguatge converteixi la resta de valors en cadenes i els concateni un darrera l'altre.</p>
                                        <p>Recordeu també que la classe String (la pròpia de java), ja disposa d'una utilitat anomenada <em>substring</em> que permet retallar cadenes. Trobareu informació de com fer servir aquest mètode consultant <a target=_blank" href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#substring-int-int-">l'API de la classe String</a>. Tot i això les vostres funcions hauran d'afegir 3 punts quan els calgui retallar cadenes.</p>
                                        <p>D'altra banda haureu de tenir en compte que la classe String no disposa de cap utilitat específica per farcir cadenes. Per aconseguir-ho, podeu anar afegint reiteradament els caràcters de farciment fins aconseguir la mida desitjada.</p>
                                    </div>  
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion20" 
                                            data-selector-clue="#slc-discussion20-clue2">
                                        Pista 2
                                    </button>                                        
                                    <div id="slc-discussion20-clue2" class="iocClue hidden">
                                        <h2>Pista 2</h2>
                                        <p>Intenteu escriure les funcions reutilitzant tant codi com pugueu. Si durant la codificació us adoneu que repetiu seqüències de codi molt semblants, plantegeu-vos que potser és possible encapsular el codi en una única funció i fer les crides pertinents quan calgui.</p>
                                    </div>  
<!-- Button trigger modal -->
                                    <button type="button" class="btn btn-primary btn-lg toggle-off  btn-3d" 
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion20" 
                                            data-selector-solution="#slc-discussion20-solution">
                                        Solució
                                    </button>
                                    <div id="slc-discussion20-solution" class="iocSolution hidden">
                                    <p>Classe Strings:</p>
                                        <pre><code class="java">
public class Strings {
    /**
     * Genera i retorna una nova cadena a partir de la cadena passada al primer 
     * paràmetre i el caracter de farciment del segon paràmetre. En cas que la 
     * cadena tingui una mida menor al valor absolut del tercer paràmetre, es genera 
     * una nova cadena concatenant tants caracters de farciment com sigui 
     * necessàri. Si el tercer paràmetre és un valor positiu es farcirà la 
     * cadena per la dreta. Si és un valor negatiu es farcira per l'esquerra.
     * @param cadena és la cadena base per la que es comença la cadena nova.
     * @param farciment és el caràcter de farciment per omplir la nova cadena 
     * fins adquiri la mida demanada
     * @param mida és la mida de la que es disitja la nova cadena.
     * @return la nova cadena generada
     */
    public static String farcirFinsMida(String cadena, char farciment, int mida){
        int midaActual = cadena.length();
        boolean esquerra = mida &lt; 0;
        
        mida = Math.abs(mida);
        
        while(midaActual&lt;mida){
            if(esquerra){
                cadena = farciment + cadena;
            }else{
                cadena += farciment;
            }
            midaActual++;
        }
        return cadena;
    }      

    /**
     * Retorna una cadena generada a partir de la cadena passada en el primer 
     * paràmetre. En cas que la cadena superi la mida del valor del segon 
     * paràmetre, aquesta es retallarà de manera que en concatenar-hi pres punts 
     * esdevingui una cadena de la mida exacta indicada en el segon paràmetre.
     * @param cadena és la cadena base per la que es retallarà si cal.
     * @param mida és la mida de la que es desitja la nova cadena.
     * @return la nova cadena generada
     */
    public static String retallarFinsMida(String cadena, int mida){
        int midaActual = cadena.length();
        
        if(midaActual&gt;mida){
            cadena = cadena.substring(0, mida-3);
            cadena += "...";
        }
        return cadena;
    }      

    /**
     * Retorna una cadena generada a partir de la cadena passada en el primer 
     * paràmetre. En cas que la cadena superi la mida del valor del tercer
     * paràmetre (mida), aquesta es retallarà de manera que en concatenar-hi 
     * tres punts esdevingui una cadena de la mida exacta indicada per mida.
     * En cas que la cadena tingui una mida menor al valor de mida, es genera 
     * una nova cadena concatenant tants caràcters de farciment com sigui 
     * necessari.
     * @param cadena és la cadena base per la que es retallarà si cal.
     * @param mida és la mida de la que es desitja la nova cadena.
     * @return la nova cadena generada
     */
    public static String midaExacta(String cadena, char farciment, int mida){
        int midaActual = cadena.length();
        int midaAbs = Math.abs(mida);
        
        if(midaActual&gt;Math.abs(midaAbs)){
            cadena = retallarFinsMida(cadena, midaAbs);
        }else{
            cadena = farcirFinsMida(cadena, farciment, mida);
        }
        return cadena;
    }      
}
                                        </code></pre>                         
                                        <p>Classe Tasca2 de prova:</p>
                                        <pre><code class="java">
public class Tasca2 {

    public static void main(String[] args) {
        Tasca2 prg = new Tasca2();
        
        prg.prova();
    }

    private void prova() {
        String retorn;
        retorn = Strings.retallarFinsMida("Mira com es retalla aquesta frase tan llarga", 12);
        System.out.println("Strings.retallarFinsMida(\"Mira com es retalla aquesta frase tan llarga\", 12) = "
                                                                                     + retorn);
        System.out.println(retorn.length()&gt;12?"Error":"Correcte");
        System.out.println("");

        retorn = Strings.retallarFinsMida("Cadena original", 20);
        System.out.println("Strings.retallarFinsMida(\"Cadena original\", 20) = " + retorn);
        System.out.println(retorn.length()&gt;20?"Error":"Correcte");
        System.out.println("");
        
        retorn = Strings.farcirFinsMida("Cargol", '-', 35);
        System.out.println("Strings.farcirFinsMida(\"Cargol\", '-', 35) = " + retorn);
        System.out.println(retorn.length()&lt;35?"Error":"Correcte");
        System.out.println("");

        retorn = Strings.farcirFinsMida("25", '0', -6);
        System.out.println("Strings.farcirFinsMida(\"25\", '0', -6) = " + retorn);
        System.out.println(retorn.length()&lt;6?"Error":"Correcte");
        System.out.println("");
        
        retorn = Strings.farcirFinsMida("78025", '0', -4);
        System.out.println("Strings.farcirFinsMida(\"78025\", '0', -4) = " + retorn);
        System.out.println(retorn.length()&lt;4?"Error":"Correcte");
        System.out.println("");
        
        retorn = Strings.farcirFinsMida("Igual", '0', -4);
        System.out.println("Strings.farcirFinsMida(\"Igual\", '0', 4) = " + retorn);
        System.out.println(retorn.length()&lt;4?"Error":"Correcte");
        System.out.println("");

        retorn = Strings.midaExacta("Frase de prova", '.', 14);
        System.out.println("Strings.midaExacta(\"Frase de prova\", '.', 14) = " + retorn);
        System.out.println(retorn.length()!=14?"Error":"Correcte");
        System.out.println("");
        
        retorn = Strings.midaExacta("Frase de prova", '_', 20);
        System.out.println("Strings.midaExacta(\"Frase de prova\", '_', 20) = " + retorn);
        System.out.println(retorn.length()!=20?"Error":"Correcte");
        System.out.println("");
        
        retorn = Strings.midaExacta("Frase de prova", '_', -20);
        System.out.println("Strings.midaExacta(\"Frase de prova\", '_', -20) = " + retorn);
        System.out.println(retorn.length()!=20?"Error":"Correcte");
        System.out.println("");
        
        retorn = Strings.midaExacta("Frase de prova", '_', 5);
        System.out.println("Strings.midaExacta(\"Frase de prova\", '_', 5) = " + retorn);                
        System.out.println(retorn.length()!=5?"Error":"Correcte");
        System.out.println("");

        retorn = Strings.midaExacta("Frase de prova", '_', -5);
        System.out.println("Strings.midaExacta(\"Frase de prova\", '_', -5) = " + retorn);                
        System.out.println(retorn.length()!=5?"Error":"Correcte");
        System.out.println("");
    }
    
}
                                        </code></pre>
                                    </div>                                    
                                 </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Debat 2 ================-->     

                <!--=========== BEGIN SUBSECTION Debat 3 ================-->    
                <section id="slc-toDo30" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Debat 3- Tipus composts </h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                <p>Imaginem una aplicació per jugar al senzill joc de les dames.  
                                Recordeu que es juga amb un tauler de 10x10 caselles, que juguen 2 jugadors i que cada jugador disposa de 12 fitxes de diferent color que cal disposar a certes caselles del tauler. 
                                Imaginem que l'aplicació vol identificar el nom dels dos jugadors i també el nombre de partides guanyades. </p> 	
										  <p>Si decidim representar el tauler com una matriu de valors numèrics, en el que el valor zero representi les caselles buides, el valor u, 
										  representi les fitxes blanques i el valor dos, les negres; podríem crear la següent especificació per donar resposta a les necessitats de l'aplicació:</p>
										 <div class="iocexample">                                  
                                    <pre><code class="java">
public class DadesJocDames {    
    int CASELLA_BUIDA = 0;
    int FITXA_BLANCA = 1;
    int FITXA_NEGRA = 2;

    int[][] tauler = new int[10][10];
    int torn;
    Jugador jugadorBlanques;
    Jugador jugadorNegres;
}

public class Jugador {    
    String nom;
    int partidesGuanyades;
}
                                    </code></pre>
                                    </div>
                                    <p>La classe DadesJocDames contindria les dades que permeten identificar un moment determinat de la  partida que s'estigui jugant (la posició de les fitxes, el torn del jugador que li toqui tirar i les dades especifiques de cada un d'aquest agrupades com estructura Jugador). 
                                    Serà la classe Jugador, l'encarregada  de mantenir les dades específiques referents a un jugador (el nom i les partides guanyades).</p>
                                                                        <p>
												Cal deixar clar, però que l'especificació només indica la composició de les dades. 
												Per poder-es fer servir, caldrà declarar variables indicant el nom de l'estructura a usar, de forma semblant com s'indiquen el tipus de dades.                                    
                                    </p>

                                    <div class="frameBox">
                                        <h4>Questions pel debat en el <span class="forumDeDiscussio"></span></h4>
                                         <ol>
                                            <li>Creieu que l'estructura de dades DadesJocDames respon als requisits de l'aplicació?</li>
                                            <li>Com inicialitzaries les dades de l'estructura?</li>
                                        </ol>
                                    </div>
                        <p>Per accedir als elements d'una estructura de dades, després del nom de la variable concatenarem un punt seguit del nom de l'element on desitgem accedir o manipular.  </p>
                                <div class="iocexample">
                                         <pre><code class="java">      
 public class Aplicacio {
    DadesJocDames joc;

    public static void main(String[] args){
        Aplicacio aplicacio = new Aplicacio();
        aplicacio.inici();
    }

    void inici(){
        joc = new DadesJocDames();
        joc.jugadorBlanques = new Jugador();
	     joc.jugadorNegres = new Jugador();

        //Exemples d'assignació i lectura dels valors        
        joc.jugadorBlanques.nom = demanarNomJugador(joc.FITXA_BLANCA);
        joc.jugadorNegres.nom = demanarNomJugador(joc.FITXA_NEGRA);
        ...
    }
    
    ...
}
        </code></pre>
        <p>Aquest exemple que acabem de veure, només funcionarà si la classe Aplicació es troba en el mateix paquet que les classes  DadesJocDames i Jugador. 
			</p>
			<div class="frameBox">
                                        <h4>Questions pel debat en el <span class="forumDeDiscussio"></span></h4>
                                         <ol>
                                            <li>Si situem la classe Aplicació en un paquet diferent, encara que iniciem la variable joc, no podrem accedir a cap dels seus elements. Què haurem de fer en aquest cas?</li>
                                        </ol>
                                    </div>
                                    
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-toDo30" 
                                            data-selector-clue="#slc-toDo30-clue1">
                                        Pista
                                    </button>                                        
                                    <div id="slc-toDo30-clue1" class="iocClue hidden">
                                        <h2>Pista</h2>
                                         <p>En JAVA les variables que representen Estructures de dades es declaren:</p>
                                   
                                    <div class="iocexample">
                                         <pre><code class="java">
                                          NomEstructuraDeDades identificadorVariable;
                                         </code></pre>
                                    </div>
                                    
                                    <p>Abans de fer servir una variable d'algun tipus d'estructura de dades cal haver-la inicialitzat. 
                                    Si no es fa, a l'intentar usar-la obtindrem un error que aturarà l'execució. 
                                   
                                    És possible inicialitzar les variables des de la pròpia declaració: </p>
                                    <div class="iocexample">
                                         <pre><code class="java">
                                          NomEstructuraDeDades identificadorVariable = new NomEstructuraDeDades ();
} 
                                         </code></pre>
                                    </div>                       
                                          
                                        
                                    </div>
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg toggle-off btn-3d" 
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-toDo30" 
                                            data-selector-solution="#slc-toDo30-solution">
                                       Solució
                                    </button>                                        
                                    <div id="slc-toDo30-solution" class="iocSolution hidden">
                                        <h2>Solució </h2>
                                      <div class="iocexample">
                                         <pre><code class="java">
public class DadesJocDames {    
    int CASELLA_BUIDA = 0;
    int FITXA_BLANCA = 1;
    int FITXA_NEGRA = 2;

    int[][] tauler = new int[10][10];
    int torn;
    Jugador jugadorBlanques = new Jugador();
    Jugador jugadorNegres = new Jugador();
}
												</code></pre>
												<p>O bé: </p>
												<div class="iocexample">
                                         <pre><code class="java">
		DadesJocDames joc;
        
        ...
	
		public static void main(String[] args){
			//Abans d'inicialitzar el elemnts jugadorBlanques i jugadorNegres cal incialitzar joc
			...
			//inicialització en diferit	
			joc = new DadesJocDames();
			//Ja es possible inicialitzar els elements interns
			...
			joc.jugadorBlanques = new Jugador();
			joc.jugadorNegres = new Jugador();
			// a partir d'aquí ja queda tot inicialitzat.
			...
		}
		...
												</code></pre>
                                    </div>
                                   

                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Exercici 2 ================-->   
            </section>
            <!--=========== END SECTION toDo ================-->    

            <!--=========== BEGIN SECTION toDelivery ================-->    
            <section id="slc-toDelivery">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Lliurament - Classes, biblioteques i tipus composts</h2>
                             </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-12">
                            <div class=bodySlide>
                                <p>En aquesta A501 se us demana que participeu als debats proposats al <span class="forumDeDiscussio"></span>. Es recomana acabar i lliurar aquesta activitat abans de la data recomanada: <strong class='dataRecomanada'></strong> i en tot cas mai després de la data límit: <strong class="dataLimit"></strong>.</p>
                                <p>És molt important pel vostre aprenentatge que participeu en els debats proposats. També és important pel professor doncs pot avaluar l'evolució del vostre l'aprenentatge així com la utilitat l'activitat en el conjunt del procés i proposar canvis futurs si calguessin. </p>
                            </  div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toDelivery ================-->    
            
            <!--=========== BEGIN SECTION toContinue ================-->    
            <section id="slc-toContinue">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Com continuar</h2>
                             </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-12">
                            <div class=bodySlide>
                                <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en cosntrucció"> Text provisional. Estem treballant per millorar</div>                               
                                <p>Passeu a la següent <span class="toNextActivity"></span></p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toContinue ================-->    
        </div>
    </div>
    <!--=========== END MAIN SLIDER SECTION ================-->    

    <!--=========== BEGIN META-INFO PANELS ================-->    
    <div id="sidepanel-wrapper" class="left-position after-top-menu">
        <a id="panel-close" href="#" class="panel-close btn btn-light pull-right toggle"><i class="glyphicon glyphicon-remove-circle"></i></a>
        <div id="goals_info" class="bodySlide hidden"> 
            <h2>Objectius d'aprenentatge de l'activitat</h2>
            <ul>
            <li>	1. Descompodre un programa en funcions i classificar les funcions en mòduls (classes) d'acord a criteris ben definits i útils. Entre d'altres, són criteris bàsics mòduls d'entrada i sortida, mòduls de control, i mòduls de tractament de dades.</li>
				<li>	2. Implementar biblioteques reutilitzables i específiques d'una aplicació.</li>
				<li>	3. Usar estructures de dades senzilles per agrupar les dades de l'aplicació en pocs accessos.</li>
				<li>	4. Identificar quan cal instanciar les estructures de dades i compassar-les a les diverses funcions. </li>
				<li>	5. Crear instancies de classes repositori de codi abans d'executar els seus mètodes escollint si es creen a nivell local o global. En qualsevol cas cal  vigilar no entrar en inicialitzacions recursisves que malbaratin o fins i tot exhaureixin la memòria.</li>
				<li>	6. Documentar les diferents classes usant la sintaxi javadoc.</li>
				<li>	7. Usar classes internes del llenguatge JAVA: String, Arrays, Math i Random.</li>
				<li>	8. Planificar planificar les pantalles, controls i funcions d'alt nivell que estructuren un programa.</li>
				<li>	9. Fer una transferència correcte de les dades mitjançant paràmetres durant l'execució. </li>
				<li>	10. Descompondre un programa en funcions i classificar les funcions en mòduls (classes) d'acord a criteris ben definits i útils. Entre d'altres, són criteris bàsics mòduls d'entrada i sortida, mòduls de control, i mòduls de tractament de dades.</li>
            </ul>
            <h2>Resultats d'aprenentatge del mòdul treballats en aquesta activitat</h2>
            <ul>
            	 <li>Prova, depura, comenta i documenta els programes.</li>
                <li>Defineix el concepte de llibreries i la seva utilitat.</li>
                <li>Utilitza llibreries en l’elaboració de programes</li>
            </ul>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                                           
            <p>Aquí s'afegiran els resultats d'aprenentatge del mòdul que es treballen en aquesta activitat</p>
        </div>
        <div id="more_reinforcement" class="hidden"> 
            <h2>Més activitats i idees per reforçar l'aprenentatge</h2>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                               
            <p>Aquí s'afegiran exercicis, activitats, lectures o referencies externes per tal que l'estudiant, pugui reforçar el conceptes estudiats </p>
        </div>
        <div id="more_info" class="hidden"> 
            <h2>Informació sobre funcions  per ampliar</h2>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                               
            <p>Aquí s'afegiran lectures, activitats referències externes o bibliografia on l'estudiant, pugui ampliar l'aprenentatge si ho desitja</p>
        </div>
    </div>
    <!--=========== END META-INFO PANELS ================-->    
    
    <!--=========== BEGIN EMPTY PANEL ================-->    
    <div id="emptypanel-wrapper" class="right-position after-top-menu">
    </div>
    <!--=========== END EMPTY PANEL ================-->    
    
    <!--=========== BEGIN EMPTY MODAL WINDOW ================-->    
    <div id="modalWindow" class="iocModal hidden">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-selector-to-set-class="#modalWindow" data-class-to-set-class="iocModal hidden" aria-label="Close"><span aria-hidden="true">×</span></button>
            <h4 class="modal-title">Modal title</h4>
          </div>
          <div class="modal-body">
            
          </div>
          <div class="modal-footer">
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->
    <!--=========== END EMPTY MODAL WINDOW ================-->    

    <!--=========== BEGIN EMPTY LEFT COLUMN PANEL ================-->    
    <div id="leftColumnPanel" class="left-position column-panel after-top-menu">
    </div>
    <!--=========== END EMPTY LEFT COLUMN PANEL ================-->    

    <!--=========== BEGIN EMPTY HIDDEN PANEL ================-->    
    <div id="hiddenContent" class="hidden">
    </div>
    <!--=========== END EMPTY HIDDEN PANEL ================-->    

    <!--=========== BEGIN SCRIPTS ================-->    
    <!-- jQuery -->
    <script src="js/jquery.js"></script>
    <script src="js/jquery.easing.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- highlight.js plugin -->
    <script src="js/highlight.pack.js"></script>

    <!-- jssor.js plugin -->
    <script src="js/jssor.js"></script>
    <script src="js/jssor.slider.js"></script>
    
    <!-- to run jssor here-->
    <script src="js/jssorActivities.js"></script>

    <!-- slides functionality-->
    <script src="js/scrolling-slides.js"></script>

    <!-- specific functionality for IOC activities-->
    <script src="js/m03b2Activities.js"></script>

    <!-- specific functionality for this activ¡ty-->
    <script>
         $(document).ready(function(){
            var activityManager = new ActivityManager();
            
            activityManager.init("data/toReplace.json", "A501");
            var iocSlider = new IocSlider();
            activityManager.updateDisplayButtons(iocSlider);
        });
    </script>

</body>

</html>


