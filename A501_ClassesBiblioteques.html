<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
	 <meta name="author" content="Alícia Vila" >    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Activitat d'aprenentatge per introduir els conceptes de classe, biblioteques i tipus composts">
    
    
    <title>A501. Classes i biblioteques</title>
    <!-- Bootstrap Core CSS -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/bootstrap.min.css" type="text/css"/>
<!--    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/default.min.css">-->
    <link rel="stylesheet" href="js/styles/default.css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <!-- Custom CSS -->
    <!--link to css slides-->
    <link href="css/m03b2Activities.css" rel="stylesheet">
    <link href="css/scrolling-slides.css" rel="stylesheet">
    <link href="css/highlightActivities.css" rel="stylesheet">
</head>
<!-- The #page-top ID is part of the scrolling feature - the data-spy and data-target are part of the built-in Bootstrap scrollspy function -->

<body id="page-top">
<!-- Navigation hidden panel -->
    <aside>
        <a id="menu-toggle" href="#" class="btn btn-dark toggle after-top-menu" title="Informació"><i class="glyphicon glyphicon-info-sign"></i></a>
        <nav id="sidebar-wrapper" class=" after-top-menu">           
            <ul class="sidebar-nav">
                <a id="menu-close" href="#" class="btn btn-light pull-right toggle">
                    <i class="glyphicon glyphicon-remove-circle"></i>
                </a>
                <li class="sidebar-brand">
                    <a href="#slc-toStart"  onclick = '$("#menu-close").click();' >Inici activitat</a>
                </li>
                <li>
                    <a href="#" onclick = 'return $("#goals_info").togglePanelOnClick();'>Objectius</a>
                </li>
                <li>
                    <a href="#" onclick ='return $("#more_reinforcement").togglePanelOnClick(); '>Per reforçar</a>
                </li>
                <li>
                    <a href="#" onclick ='return $("#more_info").togglePanelOnClick(); '>Més informació per ampliar</a>
                </li>
            </ul>
        </nav>
        <nav id="bottom-wrapper">
             <!-- SCROLL PREVIOUS BUTTON -->
            <span id="prevArrow" class="btn arrownav previousSection" ></span>
            <!-- END SCROLL TOP BUTTON -->
             <!-- SCROLL NEXT BUTTON -->
            <span id="nextArrow" class="btn arrownav nextSection" ></span>
            <!-- END SCROLL TOP BUTTON -->
        </nav>        
    </aside>
    <!--=========== BEGIN HEADER SECTION ================-->
     <header id="header">
         <!-- BEGIN MENU -->
        <div class="menu_area">
            <nav class="navbar navbar-default navbar-fixed-top" role="navigation"> 
                <!-- LOGO -->
                <span class="navbar-brand navbar-left logo-nav"><img src="images/logo.png" title="{{$LOGO_TITLE}}" /></span>
                <div class="container-fluid">
                    <div class="navbar-header">
                    <!-- FOR MOBILE VIEW COLLAPSED BUTTON -->
                        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                          <span class="sr-only">Menú</span>
                          <span class="icon-bar"></span>
                          <span class="icon-bar"></span>
                          <span class="icon-bar"></span>
                        </button>
                    </div>
                    <div id="navbar" class="navbar-collapse collapse">
                        <ul id="top-menu" class="nav navbar-nav navbar-right main_nav">
                          <li class="active"><a href="#slc-toStart">Inici</a></li>
                          <li><a href="#slc-toKnow">Què cal saber</a></li> 
                          <li><a href="#slc-toDo">Què cal fer</a></li>
                          <li><a href="#slc-toDelivery">Lliurament</a></li> 
                          <li><a href="#slc-toContinue">Com continuar</a></li> 
                        </ul>           
                    </div>
                </div>     
            </nav>  
        </div>
        <!-- END MENU -->
    </header>
    <!--=========== END HEADER SECTION ================-->
    
    <!--=========== BEGIN MAIN SLIDER SECTION ================-->    
    <div id="mainSlider" class="iocMainPanel">
        <div class="slides">
            <!--=========== BEGIN SECTION toStart ================-->    
            <section id="slc-toStart" class="section">
                <div class="container">  <!--Bootstrap container-->
                    <!-- header -->            
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Inici activitat 501 - Classes, biblioteques i tipus composts</h2>
                             </div>
                        </div>
                    </div>
                    <!-- body -->            
                    <div class="row">
                        <div class="col-lg-12">
                             <div class=bodySlide>
                                 <p>Tal i com hem vist a l'aplicar el disseny descendent i l'ús de funcions, els programes resulten molt més llegibles i fàcils d'escalar i localitzar errors si els dividim en parts, que no si fem l'aplicació amb el codi tot seguit a la funció principal.</p>
				<p>No obstant, a mesura que el programa es fa més gran i complex, necessitem distribuir encara més la informació i, en ocasions, re aprofitar parts de codi d'uns programes a altres. Així doncs, ara anem més enllà i el que farem serà agrupar diferents funcions o mètodes que facin referència a un mateix tema en el que s'anomenen <b>mòduls</b>. 
				A JAVA aquests mòduls són equivalents al concepte de <b>classe</b>. Per tant, el que definirem a partir d'ara serà un programa dividit en diverses classes interrelacionades i organitzades, en ocasions, en diferents fitxers.</p>
				<p>De la mateixa manera, podrem organitzar grups de classes vinculades entre elles que s'anomenaran <b>biblioteques de classes</b> o <em><b>packages</b></em> en JAVA.</p> 
				<p>Per últim, també veurem que en moltes ocasions els tipus d'estructures de dades que coneixem fins ara (variables simples, arrays,...) no són suficients per representar les dades d'un programa. 
				Per això, definirem el que s'anomenen <b>tipus composts</b> com a agrupació de dades de diferents tipus i veurem com es gestionen en JAVA. 
                                 <p>Aquesta activitat us permetrà aprendre com implementar i fer servir <em>classes, biblioteques i tipus composts</em>, de manera que us serveixi de pràctica per posteriors implementacions del projecte.</p>
                                 <p>En primer lloc haureu de llegir l'apartat <em><a href="#slc-toKnow">Què cal saber</a></em>. Allà, se us explicaran els coneixements bàsics que cal saber per implementar classes, biblioteques i tipus composts. </p>
                                 <p>Després caldrà que feu els exercicis que se us demana a l'apartat <em><a href="#slc-toDo">Què cal fer</a></em>. Es tracta d'un conjunt d'exercicis que us ajudaran a consolidar l'aprenentatge dels conceptes explicats.</p>
                                 <p>A l'apartat <em><a href="#slc-toDelivery">Lliurament</a></em>, se us dóna la informació bàsica per poder fer el lliurament de l'activitat. No us oblideu de llegir l'apartat i seguir les seves indicacions</p> 
                                 <p>Finalment, a l'apartat <em><a href="#slc-toContinue">Com continuar</a></em>, us redirigirà a la següent activitat. </p> 
                             </div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toStart ================-->    

            <!--=========== BEGIN SECTION  toknow ================-->    
            <section id="slc-toKnow" class="vsections">
                <!--=========== BEGIN SUBSECTION Definició classe ================-->    
                <section id="slc-toKnow10" class=" section">
                    <div class="container">  <!--Bootstrap container-->
                        <!-- header -->            
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Què és una classe?</h3>
                                 </div>
                            </div>
                        </div>
                        <!-- body -->            
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Com hem vist fins ara, el disseny descendent ens ha permès tenir el codi d'un programa ben endreçat.
                                    No obstant, això no serà suficient quan el programa creix en mida i complexitat, ja que ens trobarem amb un programa amb molts mètodes que, igualment, ens generarà un fitxer molt llarg de llegir i localitzar errors.
                                    La solució a aquest problema és desenvolupar el codi dividint-lo en components més fàcils de modificar que s'anomenen <b>mòduls</b>, 
                                    on cadascun d'ells agrupa un conjunt de funcions o mètodes que realitzen tasques relacionades.
                                    Arribats a aquest punt, cal recordar que hem de defugir dels programes monolítics, on tot el codi es centra en un únic mòdul. 
                                     </p>
                                    <p>En general, en un programa modular cada mòdul es representa amb un fitxer de codi font diferent que facilita, entre altres, el reaprofitament. 
                                    En el cas de JAVA, un mòdul equival al que anomenem <b>classe</b> i així, un programa modular està compost pel conjunt de diverses classes, en lloc de només una, i cada classe estaria implementada en un fitxer diferent.</p>
                                    <p>L'ús que fem de les classes és:</p>
				<ul>
					<li><b>Programa en JAVA</b>: Els fitxers dels programes, pròpiament, són classes (<code>public class…</code>). En aplicar disseny descendent, el seu codi queda distribuït en un mètode principal (<code>main</code>), que indica el seu punt d’inici, junt amb diferents mètodes addicionals que poden ser cridats directament.</li>
					<li><b>Repositori de mètodes o biblioteques</b>: Correspondrien a un conjunt de mètodes definits pel propi usuari o bé pel propi llenguatge JAVA. Per exemple, la classe <code>Scanner</code>, que ofereix un repertori de mètodes per controlar la lectura de dades des del teclat (<code>nextLine()</code>, <code>nextInt()</code>, <code>hasNextFloat()</code>, etc.). </li>
					<li><b>Tipus compost</b>: Aquest mateix terme s’ha usat com a sinònim de tipus compost. Per exemple, la classe <code>String</code>, utilitzada per referir-se a cadenes de text dins de JAVA. Els tipus compostos de JAVA permeten manipular dades complexes mitjançant la crida de mètodes (<code>charAt(…)</code>,<code>indexof(…)</code>, etc.).</li>
				</ul>
				<p>Cal destacar que els tres casos anteriors tenen característiques comunes, totes les classes estan formades per mètodes i la diferència està en el context en el que s'usen i la manera d'invocar als seus mètodes.
				El cas de biblioteques i tipus composts, els tractarem en apartats posteriors.</p>
				<p>Per exemple, tot i que no ens cal conèixer el codi sencer, la classe <code>Scanner</code> ha estat desenvolupada dins d’un fitxer anomenat <code>Scanner.java</code>, i una part del seu codi és:</p>
				<pre><code class="java">
public class Scanner {
    //Altres declaracions (constants, vars. globals...) ...
	
	public String nextLine() {
		//Codi del mètode ...
	}
	
	public int nextInt() {
		//Codi del mètode ...
	}
	
	//Altres mètodes ...
}
				</code></pre>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION definició classe  ================-->    
                
                <!--=========== BEGIN SUBSECTION programa modular ================-->    
                <section id="slc-toKnow20" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Estructura d'un programa modular en JAVA</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Per a realitzar un programa modular en JAVA cal definir un criteri per distribuir els mètodes en diferents classes i, aquestes, en diferents fitxers. 
                                    És important tenir en compte que sempre ha d'haver-hi una classe principal (<code>Main class</code>) que és la que disposa d'un mètode principal declarat al seu codi i que suposa el punt d'inici de l'execució del programa.</p>
				<p>Per tal d'executar un programa modular en JAVA, només cal executar aquesta classe principal. A partir d’aquí, l’execució de les diferents instruccions segueix el flux de control habitual (figura 1), partint del mètode principal d’aquesta classe.</p>
				<figure id ="figura_flux" class="left">
                    <img width="464" src="images/activities/ic10m3u5_02.png" alt="flux de control en un programa amb classes addicionals">
                    <figcaption style="width: 510px; max-width: 75%;">
                        <span class="figuretitle">figura </span> Flux de control en un programa modular.                               
                    </figcaption>
                </figure>
				<p>Cal destacar, que a la classe principal hi ha d’haver tant el mètode <code>main</code> com el mètode <code>inici</code>. Cap dels dos és necessari a la resta de classes.</p>
				<p>En un programa modular, podem definir <b>classes addicionals</b> (que no són la classe principal) nosaltres mateix o bé altres desenvolupadors per requeriments del programa. 
				En tots els casos, les classes estaran declarades i codificades en fitxers <em>.java</em> per separat. L'objectiu principal que tindran aquests tipus de classes seran la de repositoris de mètodes.</p>
				<p>Abans de començar a implementar les classes, cal raonar en quins casos ens pot interessar dividir els mètodes d’un programa entre diferents classes. Entre altres, podeu pensar en els següents:</p>
				<ul>
					<li>Quan tenim molts mètodes</li>
					<li>Quan tenim mètodes que fan referència a un mateix concepte</li>
					<li>Quan tenim mètodes que podríem reaprofitar a altres programes</li>
				</ul>
               <p>Un exemple de programa fent servir aquestes classes addicionals o creades pel propi usuari, seria el següent: </p>                                 
   				<pre><code class="java">
public class RegistreNotes {

	public static void main(String[] args) {
		RegistreNotes programa = new RegistreNotes();
		programa.inici();
	}

	public void inici() {
		double[] notes = {2.0, 5.5, 7.25, 3.0, 9.5, 8.25, 7.0, 7.5};

	//Per cridar els mètodes cal inicialitzar la classe que els conté				
	CalculsArrayReals calculador = new CalculsArrayReals();

    //Un cop fet, cal cridar-los usant com a prefix l'identificador
	double max = calculador.calcularMaxim(notes);
	double min = calculador.calcularMinim(notes);
	double mitjana = calculador.calcularMitjana(notes);
	System.out.println("La nota màxima és " + max + ".");
	System.out.println("La nota mínima és " + min + ".");
	System.out.println("La mitjana de les notes és " + mitjana + ".");
	}
}
            </code></pre>
				<p>On la classe <em>CalculsArrayReals()</em> està definida en altre fitxer:</p>
				<pre><code class="java">
public class CalculsArrayReals {
	public double calcularMaxim(double[] array) {
		double max = array[0];
		for (int i = 1; i &lt; array.length; i++) {
			if (max &lt; array[i]) {
				max = array[i];
			}
		}
    	return max;
	}
	public double calcularMinim(double[] array) {
		double min = array[0];
		for (int i = 1; i &lt; array.length; i++) {
    		if (min &gt; array[i]) {
        		min = array[i];
    		}
		}
		return min;
	}
	public double calcularMitjana(double[] array) {
		double suma = 0;
		for (int i = 0; i &lt; array.length; i++) {
    		suma = suma + array[i];
		}
    	return suma/array.length;
	}
}
				</code></pre>
				<p>És molt important tenir en compte com es realitza la <b>invocació o crida de mètodes</b> que no estan implementats en el mateix fitxer. 
				Primer cal un pas previ d’inicialització, a partir del qual es permet la invocació dels mètodes externs. 
				En dur a terme aquest procés, s’assigna un identificador a partir del qual és possible invocar els mètodes d’aquella classe, usant-lo com a prefix a la invocació. 
				Sense aquest pas previ, és impossible invocar mètodes escrits a altres classes. La sintaxi per fer-ho és la següent:</p>
					<pre><code class="java">                                      
NomClasse identificador = new NomClasse();
identificador.nomMetode(parametres);</code></pre>
					
					<p>En nomenclatura JAVA, el procés d’inicialització s’anomena formalment <b>instanciació</b> de la classe.
               El comportament de la invocació del mètode és idèntica a quan es fa sobre un mètode escrit a la mateixa classe. 
               Només canvia la sintaxi, ja que es requereix aquest prefix producte de la inicialització. 
               Cal dir que, donades diverses invocacions a mètodes d’una mateixa classe externa, només és necessari fer la inicialització una única vegada. 
               L’àmbit i la validesa de l’identificador és el mateix que una variable.</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION programa modular ================-->    
                
                <!--=========== BEGIN SUBSECTION Biblioteques de classes: paquets ================-->    
                <section id="slc-toKnow30" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Biblioteques de classes: packages</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Una vegada tenim clar com organitzar els mètodes dins de classes diferenciades, d’acord a algun criteri d’ordenació o de reutilització de codi en el futur, 
                                    ens trobem en què per a programes amb un cert grau de dificultat, pugui ser convenient disposar d’un mecanisme que permeti organitzar conjunts de classes dins d’un programa, de la mateixa manera que una classe organitza un conjunt de mètodes. 
                                    Això permetria aplicar modularitat a conjunts de classes en bloc, en lloc de fer-ho a nivell individual, i també fer-les més fàcils de localitzar, gestionar i reaprofitar, si és el cas.</p> 
												
                                    <p class="iocimportant">Una biblioteca de classes, o <b>package</b> en Java, és un conjunt de classes vinculades entre elles d’acord a algun criteri temàtic o d’organització del seu codi i que permet organitzar aquestes classes jeràrquicament.</p> 
                                    <p>Així, un package, no és més que un directori de classes. 
                                    Per assignar una classe a un <em>package</em> cal escriure a la primera línia del seu fitxer de codi la sentència següent:</p>
                                    <pre><code> package identificadorPackage;</code></pre>  
                                    <p>Totes les classes que comparteixin el mateix identificador de package pertanyeran al mateix package.</p>
                                    
                                    <p>Per definir l'identificador dels <em>package</em> cal seguir un estàndard de notació: minúscula i paraules separades per punts que fan referència a la ubicació, per exemple:
                                    <pre><code>package ioc.m03.uf2.funcions.a501;</code></pre>  
                                    <p>Per fer servir correctament els <em>package</em> ens cal conèixer les següents restriccions:</p>
												<ul>                                    
                                    	<li>Donada una classe, aquesta únicament pot pertànyer a un <em>package</em>. No és possible usar més d’una vegada la sentència <em>package</em> en el codi font d’una classe. </li>
                                    	<li>Donat un <em>package</em>, a dintre seu mai hi poden haver dues classes amb el mateix nom.</li>                        
												</ul>
												 <p>A l'hora d'implementar, cal establir un criteri per decidir quan ens interessa dividir conjunts de classes en biblioteques diferents:</p>
										<ul>
										<li>Un programa complet, una jerarquia de packages.</li>
										<li>Molts programes petits, una jerarquia de packages.</li>
										<li>Un conjunt de classes sense un programa principal, un package.</li>
										</ul>												
												</div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Biblioteques de classes: paquets ================-->    

                <!--=========== BEGIN SUBSECTION Biblioteques de classes: ús de paquets ================-->    
                <section id="slc-toKnow35" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Biblioteques de classes: Implementació de classes que pertanyen a paquets</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>                              
                               <p>Fins ara, quan volíem referir-nos a una classe, senzillament fèiem servir el seu nom. 
                               En el moment, en que tenim classes que pertanyen a un determinat package, i volem accedir a classes que pertanyen a altre paquet, hem d'establir uns mecanismes d'accés.  
                               Donat que tota classe pertany a un <em>package</em> és convenient nomenar la classe seguint un estàndard. 
                               Així, direm que el <b>nom qualificat</b> d’una classe és la combinació de l’identificador del seu <em>package</em> junt amb el seu nom, separats per un punt. Per exemple, 
                              <pre> <code>
A501.apartat1.exemples.RegistreNotes
                               </code></pre>
                               <p>Amb un nom qualificat queda totalment clar a quin <em>package</em> pertany la classe. 
                               Això és útil ja que des del codi d’una classe que pertany a un <em>package</em> concret, 
                               només es poden usar directament classes amb què comparteixi el mateix nom de <em>package</em>. 
                               Però què ocorre si volem accedir a una classe que està a altre package diferent?
                               Si s'accedeix a una classe d’un package diferent, el compilador donarà un error, dient que no la reconeix. 
                               <p>En aquests casos, per indicar quina classe exactament s'està usant, JAVA ofereix tres opcions:</p>
									<ul>
										<li>Inicialització usant el nom qualificat: usar el nom qualificat per referir-se a la seva inicialització</li>                                                                                
                                                                              
													<pre><code class="java">
package ioc.m03.uf2.funcions.a501

public class RegistreNotes {
...
//Ús del nom qualificat per accedir a una classe d'un altre package
utilitats.arrays.CalculsArrayReals calculador = new utilitats.arrays.CalculsArrayReals();
...
}

package utilitats.arrays;
public class CalculsArrayReals {			
//Codi
...
}
													</code></pre> 
                                                                              
													<li>Importació explícita: s'ha d'importar prèviament a la capçalera del fitxer de codi font (<code>import</code>), entre la declaració del <code>package</code> i la declaració <code>public class….</code></li>
                                                                                                       
													<pre><code class="java">													
package ioc.m03.uf2.funcions.a501
//Cal importar la classe "CalculsArrayReals", ja que és d'un altre package
import utilitats.arrays.CalculsArrayReals;
public class RegistreNotes {
//Codi
...
}
package utilitats.arrays;
//No s'usa cap classe fora d'aquest package, no s'importa res
public class CalculsArrayReals {
//Codi
...
}		
													</code></pre> 
                                                                                                      
													<li>Importació general: es fa servir quan es volen usar moltes classes del mateix <code>package</code> i importar-les una a una es fa pesat. Es tracta d’usar un asterisc, “*”, en lloc del nom de la classe en el nom qualificat. 
													Aquest fa de comodí i equival a dir “absolutament totes les classes del package”.</li>                                                                                                       
													<pre><code class="java">	
package ioc.m03.uf2.funcions.a501;
//S'importarien totes les classes del package utilitats.arrays
import utilitats.arrays.*;
public class RegistreNotes {
//Codi
...
}		
												</code></pre>	
												</ul> 
												<p>Per norma general, és aconsellable usar la importació explícita, 
												ja que així a l’inici del vostre codi font sempre disposareu d’una llista detallada de quines classes d’altres biblioteques esteu usant.</p> 
												<p>Una vegada es té clar com referenciar les classes que pertanyin a un determinat paquet, cal treballar amb elles com hem fet fins ara.</p>                                                     
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Biblioteques de classes: ús de paquets ================-->        

                <!--=========== BEGIN SUBSECTION Biblioteques de JAVA: API ================-->    
                <section id="slc-toKnow40" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >L'API de JAVA</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>Per crear programes modulars no és necessari crear cadascun dels mòduls que formen part del programa. Sovint els llenguatges de programació incorporen 
                                    biblioteques de mòduls auxiliars que ja han estat completament desenvolupats. Aquests mòduls auxiliars ofereixen funcionalitats que van més enllà del que permet la seva sintaxi estrictament
                                    o incorporant l’opció d’executar blocs de codi que resolen tasques que es consideren de propòsit general i que poden ser d’utilitat en una àmplia gamma de programes.</p>
                                    En el cas del llenguatge Java, el seu kit de desenvolupament (JDK) incorpora un quantiós repositori de classes, organitzats en diferents packages d’acord a la seva temàtica, que poden ser accedides lliurement en realitzar qualsevol programa. 
                                    Aquest repositori és el que s’anomena l’<b>API</b> de JAVA. 
                                    <p>La documentació de l’API de JAVA ofereix un enorme repertori de classes que contenen mètodes amb funcionalitats molt diverses.</p>
                                    <p>Els <em>packages</em> que contenen les classes més usuals són:
												<ul>
													<li><code>java.lang</code>: conté totes les classes vinculades a operacions essencials dels tipus de dades del llenguatge.</li>
													<li><code>java.util</code>: una mena de calaix de sastre amb classes de propòsit general.</li>
													<li><code>java.io</code>: conté totes les classes vinculades a entrada / sortida (tractament de fitxers).</li>
													<li><code>javax.swing</code>: conté les classes bàsiques vinculades a la creació d’interfícies gràfiques.</li>
												</ul>
												<p>L’avantatge de conèixer aquests paquets és que, com que aquestes classes ja estan creades i incorporades com a part del llenguatge, si en trobeu una que ja faci la feina requerida, us estalviareu haver d’escriure parts de codi font del programa.</p>
												<p>Per poder usar qualsevol classe d’entre les definides a l’API de JAVA cal seguir exactament les mateixes passes que per a una classe realitzada per vosaltres, però dins un <em>package</em> diferent: importar-la a l’inici del codi font i inicialitzar-la. 
												Un cop fet, la sintaxi per invocar els seus mètodes és exactament la mateixa. Aquest procés només té una particularitat molt especial, i és que no cal disposar del codi font de la classe en qüestió. En estar incorporada dins el JDK, Java ja sap localitzar el seu codi automàticament.</p>
												<p>Per exemple, suposeu que heu de fer un programa que ha de generar dos valors reals a l’atzar, entre 0 i 100, i voleu que els mostri per pantalla. 
												D’entrada, resoldre aquest problema suposaria haver de crear dins del codi font algun mètode que generés aquests valors reals aleatoris, donat que existeix una classe anomenada Random ja incorporada a l’API de Java, la podem fem servir.
												Cercant-la a la documentació de l’API de Java, es veu que forma part del <code>package java.util</code>. A continuació veiem com es pot fer servir aquesta classe:</p>
                                    
                                 <pre><code class="java">
package ioc.m03.uf2.funcions.a501;
//Importació de la classe, en estar en un altre package
import java.util.Random;
public class RealsAleatoris {
	public static void main(String[] args) {
		RealsAleatoris programa = new RealsAleatoris();
			programa.inici();
							}
	public void inici() {
			//Cal generar un valor a l'atzar
			//Cal generar-ne l'altre
			//Mostrar-los
								}
						}
                                    </code></pre>
                                    <p> Com forma part de l’API de Java, l’ús de la classe Random no implica la incorporació de cap altre fitxer de codi font.
                                     Un cop ja està tot llest per usar-la, caldrà mirar quins mètodes ofereix per generar reals a l’atzar.</p>   
                                     <p>Cal destacar que el procés tot just descrit ja l’heu usat anteriorment en diverses ocasions, per exemple, cada cop que us calia llegir dades pel teclat i heu usat <em>Scanner</em>. 
                                     Si mireu la documentació de l’API de JAVA, trobareu aquesta classe dins el mateix <code>package java.util</code>.</p>     
                                     <p>Algunes classes de Java tenen una particularitat, i és que a l’hora d’inicialitzar-les cal especificar un conjunt d’informació addicional en forma de <b>paràmetres</b>.                                      
												 <p>Fins al moment, s’ha dit que per inicialitzar una classe per tal de poder invocar els mètodes que ofereix calia fer:</p>
												  <pre><code class="java">
NomClasse identificador = new NomClasse();
												  </code></pre>   
												 <p>Però hi ha casos en què, per inicialitzar correctament la classe, cal afegir un conjunt de valors entre els parèntesis, de manera idèntica a com es faria en invocar un mètode. Si no es posen aquests paràmetres quan pertoca, hi haurà un error de compilació.</p>                       
													<pre><code class="java">
NomClasse identificador = new NomClasse(paràmetres);
												  </code></pre>   
												  <p>Per exemple, la classe <em>Scanner</em>. Per inicialitzar-la correctament li cal un paràmetre indicant quin sistema d’entrada ha de processar:</p>
												  <pre><code class="java">
Scanner lector = new Scanner(System.in);
												  </code></pre>   
												  <p>Per veure si cal o no incloure un paràmetre en inicialitzar una classe, caldrà cercar-lo a la seva documentació. Concretament, a l’apartat anomenat resum de constructors (<em>Constructor Summary</em>) indica la sintaxi de la part dreta de la inicialització.</p>                       
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Biblioteques de JAVA: API ================-->        

                <!--=========== BEGIN SUBSECTION Mètodes estàtics ================-->    
                <section id="slc-toKnow41" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Mètodes estàtics</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>En general, per poder invocar mètodes d’una classe cal inicialitzar-la prèviament. 
                                    Ara bé, d’entre tots els mètodes proporcionats dins de les classes disponibles a l’API de Java, hi ha un petit subconjunt que s'anomenen <b>mètodes estàtics</b> que poden ser invocats
                                    sense haver d' inicialitzar la seva classe. S’identifiquen perquè a la documentació apareixen marcats amb la paraula clau <code>static</code>. </p>
												<p>Per invocar aquests mètodes, la sintaxi correcta és posar com a prefix el nom de la classe directament. A part d’això, el seu comportament és idèntic a qualsevol altre mètode. És a dir: </p>                                    
                                    <pre><code class="java">
NomClasse.nomMetode(paràmetres);
                                    </code></pre>   
                                    <p>Per exemple, donat el mètode estàtic <code>sqrt</code> definit a la classe <code>Math</code>: </p>
                                       <pre><code class="java">
double resultat = Math.sqrt(36);
                                    </code></pre> 
                                    <p>A continuació veurem els mètodes estàtics d'algunes de les classes més importants:</p>
                                    <ul>
												<li><b>La classe Math: </b>Pertany al <em>package</em> <code>java.lang</code>, i per tant pot ser usada sense haver d’importar-la. 
												Ofereix un ventall de mètodes estàtics per realitzar operacions matemàtiques avançades com: arrodoniment de valors(<code>round(valor)</code>), potència(<code>pow(base, exponent)</code>), arrel quadrada (<code>sqrt(valor)</code>), màxims i mínims (<code>max(a, b)</code>, <code>min(a, b)</code>),...Per exemple:
 <pre><code class="java">												
package ioc.m03.uf2.funcions.a501;
import java.util.Random;
public class ArrodonirReal {
public static void main(String[] args) {
ArrodonirReal programa = new ArrodonirReal();
programa.inici();
}
public void inici() {
//Inicialització de Random
Random rnd = new Random();
//Ús per generar un real entre 0 i 1
double valor = rnd.nextDouble();
System.out.println("El valor real generat és " + valor);
//Ús del mètode estàtic. No cal inicialitzar res, es pot usar directament.
//No cal importar-la, ja que pertany a java.lang
long arrodonit = Math.round(valor);
System.out.println("El valor arrodonit és " + arrodonit);
}
}
</code></pre>  
												</li> 
												<li><b>La classe Array:</b>Pertany al <em>package</em> <code>java.util</code> (com Random i Scanner). 
												Ofereix mètodes estàtics per fer operacions típiques amb arrays (ordenacions(<code>sort(array)</code>), còpies(<code>copyOfRange(array, posInici, posFi)</code>) , cerques(<code>binarySearch(array, clau)</code>), igualtats (<code>equals(array1, array2)</code>), conversió a text (<code>toString(array)</code>), etc.). 
												Per usar-los cal tenir present que alguns d’aquests manipulen els paràmetres d’entrada de tipus compost, en aquest cas arrays. Per tant, en finalitzar la invocació, l’array original haurà canviat.
												A continuació podem veure un exemple:
<pre><code class="java">												
package ioc.m03.uf2.funcions.a501
import java.util.Arrays;
public class OrdenaArrayText {
public static void main (String[] args) {
OrdenaArrayText programa = new OrdenaArrayText();
programa.inici();
}
public void inici() {
String[] array = {"Un", "Dos", "Tres", "Quatre", "Cinc"};
Arrays.sort(array);
System.out.println("Els elements ordenats són:");
for (int i = 0; i < array.length; i++) {
System.out.println(array[i]);
}
}
}	
</code></pre> 
											
												</li>                                 
                                    </ul>      
                                    <p>Hi ha moltes més classes que podeu consultar per tal de conèixer com funcionen aquests mètodes estàtics. </p>              
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Mètodes estàtics ================-->       
                
                <!--=========== BEGIN SUBSECTION Estructures de dades: Tipus composts ================-->    
                <section id="slc-toKnow50" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Estructura de dades: Tipus composts</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                <p>Com ja heu anat veient amb l'experiència que porteu programant, quan implementem una aplicació gran, la quantitat de dades es multiplica. 
                                Sortosament, ja hem vist que podem fer servir arrays per agrupar dades. Ara bé, no totes les dades es poden emmagatzemar en arrays, i necessitarem cercar altra solució, com definir altre tipus de variable o definir-ne moltes.  
                                En aquests casos, l'ús de variables globals està totalment desaconsellat perquè treballar amb moltes variables a l'hora que podria comportar molts errors a més de la poca eficiència que suposa definir un nombre desmesurat de variables. 
                                Malgrat tot, l'alternativa de treballar amb variables locals no és menys arriscada ja que sovint, en els processos de nivell alt sobretot, podem arribar a necessitar moltes variables i pot ser realment tediós haver-les de passar per paràmetres i per descomptat, en el fons també una font d'errors.
                                Per pal·liar això, molts llenguatges de programació permeten la creació d'<b>estructures de dades</b>. 
                                Es tracta d'una forma d'agrupar dades de diferent tipus que fan referència a un mateix concepte, mantenint-les organitzades. 
                                L'estructura de dades ideal per una aplicació gran, és una estructura jeràrquica que permeti obtenir subconjunts de dades coherents escollint el tros adequat de la jerarquia. Quan parlem d'estructura jeràrquica ens referim a algun sistema en que unes dades s'englobin dins d'altres formant un arbre.</p>
										 
										<p>Seleccionar la jerarquia correcta no sempre es senzill. Si l'aplicació es petita, és possible agrupar totes les dades en un sol bloc, o crear un número reduït de blocs independents.
										Internament, cada bloc tindrà un un conjunt de dades de diversos tipus, és a dir, un bloc de dades pot estar composat de dades de diversos tipus (enters, cadenes, vectors,...) per tal d'aconseguir la jerarquia desitjada.</p>	                                
                                   
												El concepte d'estructura de dades és senzill, però per usar-lo cal tenir ben clar el significat d'instància de l'estructura i conèixer unes regles bàsiques.</p>
												<p class="iocimportant">Les estructures de dades són organitzacions més o menys complexes de dades, de tal forma que la seva organització ens configura un valor extra que ens ajuda a interpretar la informació que representen. Per exemple, hem de considerar una estructura de dades el conjunt de valors que poden identificar i representar una persona. Per exemple el seu nom, la seva edat, el seu DNI, les titulacions que posseeix, els treballs que ha realitzat, etc.</p>
												<p>Els llenguatges de programació donen suport a les estructures de dades per mitjà dels tipus compostos de dades i concretament, el llenguatge JAVA, fa servir classes per definir els seus tipus de dades compostos.</p>
												<p class="iocimportant">Els tipus de dades compostos (classe en el llenguatge JAVA) permeten definir com s'identifiquen i organitzen els valors entre sí. Com identificadors usarem noms conceptuals que ens ajudin a interpretar el que representen.</p>
												<p>Per exemple, si haguéssim d'implementar una calculadora que hagués de fer les 4 operacions bàsiques entre dos números qualsevol, el tipus compost a fer servir podria ser:</p>
												                                    
                                    <div class="iocexample">
                                         
                                    <pre><code class="java">
package ioc.m03.uf2.funcions.a501;
public class DadesCalculadora {
    double operador1;
    double operador2;
    char operacio;    
    double resultat;
}
                                         </code></pre>
                                    </div>
                                    <figure id ="figura_instanciacio" class="left">
                                        <img width="464" src="images/activities/tipusCompostInstancia.png" alt="instanciació de tipus compostos">
                                        <figcaption style="width: 510px; max-width: 75%;">
                                            <span class="figuretitle">figura </span> Instanciació d'un tipus compost.                               
                                        </figcaption>
                                    </figure>
                                    <p>Fixeu-vos que els tipus compostos no són les dades pròpiament, sinó les variables de classe que contindran les dades. En altres paraules, són el que defineix quina forma han de tenir les dades, com han de ser, quins seran els identificadors dels valors i quina la organització interna.
I les dades? com hi afegim les dades? Abans d'explicar-ho m'agradaria remarcar que les dades no s'emmagatzemen a l'estructura. El llenguatges de programació només poden emmagatzemar dades a la memòria i és allà on aniran a parar les dades. Ara bé, per a què serveixen aleshores els tipus compostos? Doncs l'explicació que més s'hi aproxima és que actuen de plantilla. Així, els tipus compostos emmotllen la memòria per poder-hi emmagatzemar dades en la forma definida en cada tipus compost. En l'argot dels llenguatges de desenvolupament, en comptes de parlar d'emmotllar, es parla d'instanciar (figura 1). De fet, les dades de la memòria són instancies d'algun tipus de dades (siguin o no compostos).</p>
<p>Cada tipus compost pot instanciar múltiples dades a la memòria de forma simultània. Cada dada manté els seus propis valors.
A la pràctica, la instanciació es fa sobre una variable i es fa servir la paraula clau <em>new</em> seguida del tipus compost a instanciar amb els parèntesis d'execució:</p>
                                    <div class="iocexample">
                                         <pre><code class="java">
DadesCalculadora operacio1 = new DadesCalculadora();
DadesCalculadora operacio2 = new DadesCalculadora();
                                         </code></pre>
                                    </div>
                                    
                                    <p> A partir d'una instancia de tipus compost (variable), podem accedir als seus elements per modificar o obtenir el seu valor escrivint després del nom de la variable, un punt seguit del nom de l'element. Exemple:</p>
                                    <div class="iocexample">
                                         <pre><code class="java">
operacio1.operador1 = 5;
operacio1.operador2 = 3;
operacio1.operacio = '+';
...
if(operacio1.operacio == '+'){
    operacio1.resultat = operacio1.operador1 + operacio1.operador2;
} 
                                         </code></pre>
                                    </div>
                                    <p>En el llenguatge JAVA no és possible donar valors a una estructura si no s'ha creat la instancia del seu tipus compost. Si ho féssim obtindríem un error:</p>
 												<div class="iocexample">
                                         <pre><code class="java">
DadesCalculadora operacio2;
operacio1.operador1 = 7; //Això dona error perquè no s'ha instanciat la variable: operacio2 = new DadesCalculadora() 
												</code></pre>
                                    </div>                                   
                                    <p>Altra qüestió important que hem de tenir en compte a l'hora de treballar amb estructures de dades és l'accés a un element de l'estructura des d'una classe que es trobi fora del paquet on es declara l'estructura.
                                     Així, una opció seria declarar públics els elements de l'estructura. Si posem la paraula <code>public</code> davant de la declaració de cada element, a l'especificació, els elements seran accessibles des de qualsevol classe, comparteixin o no paquet amb l'estructura de dades.
Una altre forma força útil de aconseguir l'accés, sense necessitat de declarar públics els elements de l'estructura, seria usant un classe extra que permeti l'accés  i funcioni com una biblioteca específica d'una estructura de dades. 
Aquesta classe caldria situar-la al mateix paquet que l'estructura de dades i contindria mètodes per accedir al valor de les dades de l'estructura o per modificar-lo. 
També resulta molt útil per verificar que les dades a introduir seran sempre vàlides. Es tracta doncs d'una opció força aconsellable. </p>
                                    <p>Els elements d'una classe tenen diferents tipus d'accessos: </p>
                                    <ul>
                                        <li><em>public</em>: qualsevol altra classe té accés a l'element estigui o no al mateix paquet </li>
                                        <li><em>private</em>: l'accés a l'element està restringit a la pròpia classe, és a dir, no es pot accedir des d' altres classes. Aquest tipus d'accés es fa servir més endavant quan feu programació orientada a objectes. </li>
                                        <li><em>per defecte (sense tipus d'accés)</em>: l'element de la classe només potser utilitzat des de classes que estiguin al mateix paquet que la classe en la que es defineix l'element </li> 
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Estructures de dades: Tipus composts ================-->  
                
               <!--=========== BEGIN SUBSECTION Guia modularitzar ================-->    
                <section id="slc-discussion12" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal saber - Classes, biblioteques i tipus composts</h2>
                                     <h3> Guia per modularitzar usant classes addicionals i paquets</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>A mida que treballem amb aplicacions cada cop més grans, no n'hi ha prou només en agrupar el codi en funcions, sinó que caldrà classificar les funcions en classes i les classes en paquets per tal de poder-les localitzar, memoritzar i utilitzar amb certa eficiència. 
                                    A les persones ens costa menys treballar amb conceptes jeràrquics que no pas amb llistes llargues, malgrat que al final el nombre d'elements inclosos en ambdós (jerarquia o llista) sigui similar.
                                    A continuació us mostrem un conjunt de criteris que poden fer-se servir per organitzar el codi. </p>
                                    
                                    <h4 id="us_de_paquets_obligatoris" class="frameBoxHeader">Ús de paquets obligatoris</h4>
                                    <div class="frameBox smallFont">
                                        <p>Per tal que sigui possible la reutilització de classes i funcions en múltiples aplicacions, serà necessari ubicar les classes sempre en algun paquet, per tal d'evitar la repetició de noms i facilitar-ne la localització.</p>
                                        <p>S'aconsella que les classes estiguin sempre ubicades en un seqüència de paquets que permetin identificar la organització, el departament i/o equip que les desenvolupa, així com el projecte en que s'han desenvolupat. Per exemple suposant que el vostre grup fos un equip de desenvolupament del IOC,  que fos el grup número 5 i que treballéssiu en un projecte per crear utilitats per a processar imatges, la seqüència mínima de paquets amb les que hauríeu de treballar seria: <em>ioc.m03b2.grup5.imatges</em></p>
                                        <p>Aquesta seria per dir-ho d'alguna manera l'arrel a partir de la qual començaríeu a penjar-hi classes i paquets més específics.</p>
                                    </div>

                                    <h4 id="aillament_de_codi_reutilitzable" class="frameBoxHeader">Aïllament del codi reutilitzable</h4>
                                    <div class="frameBox smallFont">
                                        <p>És evident que si el que volem és poder reutilitzar funcions, no només cal adaptar les funcions fent que algunes d'elles siguin realment reusables, sinó que cal separar perfectament les funcions genèriques (reutilitzables) de les específiques (poc reutilitzables). L'ideal és agrupar les funcions genèriques en biblioteques (paquets i classes) per tal de poder-les passar en bloc d'un projecte a un altre.</p>
                                    </div>

                                    <h4 id="agrupacio_tematica" class="frameBoxHeader">Agrupació temàtica</h4>
                                    <div class="frameBox smallFont">
                                        <p>L'agrupació temàtica permet organitzar les funcions de forma jeràrquica aglutinant-les en categories cada cop més genèriques. Les funcions s'agregarien en classes i aquestes en paquets. Si fos necessari, es podrien establir també agrupacions de paquets, a fi d'anar estructurant la jerarquia. La profunditat d'aquesta dependrà del nombre de funcions que calgui organitzar. Si són poques, potser n'hi haurà prou en fer servir només classes per realitzar la classificació temàtica. És el que java fa en agrupar funcions a la classe Math, a la classe Arrays o a la classe String. Cada classe representa una categoria diferent.</p>
                                        <p>Ara bé, si consideréssim que una d'elles tingués a un nombre de funcions excessiu, es podria reduir la quantitat, seleccionant una temàtica més específica. Per exemple es podria crear una classe només per funcions trigonomètriques, una altra per funcions estadístiques, una altra per les aritmètiques i així successivament. Les tres classes podrien agrupar-se en una paquet específic anomenat <a href="#" data-toggle="tooltip" data-original-title="JAVA aconsella que els noms dels paquets s'escriguin totes les lletres en minúscules per tal de distingir-los dels noms de les classes"><em>math</em></a> per tal d'anar gestant una organització jeràrquica fàcil de manipular</p>
                                        <p>Per exemple, suposant que el nostre paquet arrel fos <em>ioc.m03b2.grup5.utilitats</em>, l'estructura quedaria de la següent manera:</p>
                                        <ul>
                                            <li>ioc
                                                <ul>
                                                    <li>m03b2
                                                       <ul>
                                                           <li>grup5
                                                               <ul>
                                                                   <li>utilitats
                                                                       <ul>
                                                                           <li>String</li>
                                                                           <li>Arrays</li>
                                                                           <li>math
                                                                                <ul>
                                                                                    <li>Trigonometriques</li>
                                                                                    <li>Estadistiques</li>
                                                                                    <li>Aritmetiques</li>
                                                                                    <li>...</li>
                                                                                </ul>
                                                                           </li>
                                                                       </ul>
                                                                   </li>
                                                               </ul>
                                                           </li>
                                                       </ul>
                                                   </li>
                                                </ul>
                                            </li>
                                        </ul>
                                    </div>
                                    
                                    <h4 id="organitzacio_estructural" class="frameBoxHeader">Organització estructural</h4>
                                    <div class="frameBox smallFont">
                                        <p>La organització estructural fa referència a la divisió jeràrquica que les aplicacions. Bàsicament es pot desprendre del propi disseny descendent.</p>
                                        <p>La principal dificultat amb la que ens trobarem quan haguem de fer una divisió d'aquestes característiques és que el disseny descendent evidencia la funcionalitat però no ens aporta informació de com agrupar-la en classes i paquets. Per tant, cal disposar d'indicadors que ens ajudin a valorar si estem fent una bona classificació.</p>
                                        <p>Un indicador fonamental és la mida de la classe. Desconfieu d'aquelles agrupacions que donin com a resultat classes amb molt poques funcions. Resulta difícil establir un nombre correcta de funcions que hauria de tenir una classe, però és evident que generalment n''ha de tenir més d'una, més de dos i segurament més de tres. De forma semblant, cal desconfiar també de les classes que aglutinin moltes funcions i caldria plantejar-nos si fos possible, alguna divisió que en reduís el nombre.</p>
                                        <p>Un segon indicador que també hauríem de tenir en compte, consisteix poder explicar la funcionalitat d'una classes de forma clara i més o menys breu. Per tant caldrà també desconfiar d'aquelles classes, que per explicar el que fan hem de matisar excessivament o elaborar una llista de coses que fan, perquè probablement ens trobem davant d'una classe excessivament específica i per això ens cal matisar tant el seu paper (el primer cas) o  que aglutina funcions poc o gens relacionades entre elles (el segon cas).</p>
                                        <p>Per il·lustrar-ho, farem una mica de <a href="#" data-toggle="tooltip"  data-html="true" data-original-title="La pràctica del <em>codi-ficció</em> és una eina de reflexió molt útil per l'aprenentatge. Intenteu-lo practicar sovint"><em>"codi-ficció"</em></a>. És a dir, prendrem de model una aplicació ben coneguda per nosaltres i intentarem deduir com la implementaríem fent servir els recursos i coneixements que tinguem en cada moment.</p>
                                        <p>Sigui per exemple, el nostre model, un lector de documents amb format com ara els documents pdf. Si voléssim crear una aplicació que llegís i mostres per pantalla fitxers contenint  documents amb format, caldria analitzar quina és la seva funcionalitat a partir del seu disseny descendent</p>
                                        <p>Per simplificar-ho ens plantejarem la implementació d'una aplicació simple, que únicament s'encarregui de localitzar un document al sistema de fitxers, llegir-lo, analitzar-ne el seu contingut i mostrar-lo per pantalla d'acord amb les regles de format que disposi. Un possible esquema de disseny podria ser:</p>
                                        
                                       <ol class="nestedCounter">
                                          <li>Localització del document
                                                <ol>
                                                    <li>Entrada de la ruta de directoris si l'usuari coneix la ruta sensera</li>
                                                    <li>Navegació per sistema de fitxers fins localitzar el fitxer desitjat
                                                        <ol>
                                                            <li>Mostrar el contingut d'un directori com a directori actual</li>
                                                            <li>Seleccionar un element del directori actual</li>
                                                            <li>...</li>
                                                        </ol>
                                                    </li>
                                                </ol>
                                            </li>
                                           <li>Càrrega del contingut del document
                                                <ol>
                                                    <li>Obertura del fitxer</li>
                                                    <li>Càrrega en memòria del contingut</li>
                                                    <li>...</li>
                                                </ol>
                                            </li>
                                            <li><a href="#" data-toggle="tooltip" data-original-title="En argot informàtic s'anomena rederització al procés d'analitzar dades amb format i plasmar en la pantalla una visualització d'aquestes seguint les indicacions del format">Renderització del contingut</a>
                                                <ol>
                                                    <li>Anàlisi del contingut per aplicar les regles de renderització segons el format</li>
                                                    <li>Donar les instruccions pertinents al dispositiu (pantalla) per visualitzar el contingut</li>
                                                </ol>
                                            </li>
                                        </ol>
                                        <p>Tenint en compte els criteris de mida i descripció indicats més amunt, probablement obtindríem entre 3 i 4 classes. En primer lloc trobarem la classe encarregada de localitzar el document, que podem anomenar <em>SelectorDocument</em>. Podríem sentir ganes de dividir aquesta en dos, una pel cas d'entrada de la ruta i una altre pel cas de navegació a través de l'arbre de directoris, però segurament el nombre de funcions que contindria el primer cas seria tant minúscul que aconsellaria agrupar-ho tot en una única classe.</p>
                                        <p>En segon lloc planificaríem la implementació de la classe encarregada de la càrrega del contingut del fitxer a la memòria de l'aplicació. Es pot anomenat <em>CarregadorDocument</em></p>
                                        <p>Finalment, serà necessari planificar la implementació de la classe encarregada de la renderització que anomenaríem <em>Render</em>. Cal clarificar però, que en funció de la complexitat del format, potser seria adequat dividir la classe en dos, per tal de reduir-ne la seva mida. En aquest cas planificaríem la creació de la classe <em>AnalitzadorDocument</em> i <em>GestorPantalla</em>, les quals estarien agrupades en un paquet anomenat <em>render</em>. Paquets i classes (incloent els paquets arrel) podrien quedar així:</p>
                                       <ul>
                                            <li>ioc
                                                <ul>
                                                   <li>m03b2
                                                       <ul>
                                                           <li>grup5
                                                               <ul>
                                                                   <li>lector
                                                                       <ul>
                                                                          <li>SelectorDocument</li>
                                                                          <li>CarregadorDocument</li>
                                                                          <li>render
                                                                              <ul>
                                                                                  <li>AnalitzadorDocument</li>
                                                                                  <li>GestorPantalla</li>
                                                                              </ul>
                                                                          </li>
                                                                       </ul>
                                                                   </li>
                                                               </ul>
                                                           </li>
                                                       </ul>
                                                   </li>
                                                </ul>
                                            </li>
                                       </ul>
                                    </div>                               
                                    <h4 id="dades_i_gestors de dades" class="frameBoxHeader">Dades i gestors de dades</h4>
                                    <div class="frameBox smallFont">
                                        <p>Separar les dades i unificar-les en una estructura, és una bona solució per tenir un accés general a les dades des de qualsevol punt de l'aplicació peró evitant els inconvenients de les declaracions globals. Així, les dades quedarien sempre encapsulades en una estructura declarada com a variable local que caldria passar per paràmetre a les diferents funcions, però un cop rebut el paràmetre resulta fàcil tenir accés a qualsevol valor de l'estructura.</p>
                                        <p>Tot i així, si l'estructura de dades presenta certa complexitat, pot resultar util per els programadors que no han dissenyat l'estructura disposar d'una classe que els faciliti l'accés. Aquesta classe actuaria com a gestor de les dades i permetria obtenir o assignar valors parcials a les dades sense necessitat de coneixer exactament l'estructura interna. Es a dir contindria funcions per facilitat l'accés a parts de l'estructura de les dades, tant per llegir els valors com per modificar-los.</p>
                                    </div>
                                    <h3 id="interficie_i_control" class="frameBoxHeader">Interfície d'usuari i control d'accions</h3>
                                    <div class="frameBox smallFont">
                                        <p>Una altra opció cada cop més usada consisteix en separar radicalment el codi destinat a mostrar informació i capturar entrades de l'usuari (el que habitualment es coneix com interfície d'usuari de l'aplicació) del que podriem dir, el tractament de les dades.</p>
                                        <p>De fet, normalment es classifiquen les funcions en tres categories i s'agrupen segons aquestes. Les 3 categories són: interfície d'usuari, encarragada de l'intercanvi d'informació entre l'aplicació i l'usuari, control de les peticions, encarregada de gestionar cada una de les peticions del l'usuari a fi de reconduir el flux del programa per aconseguir resoldre amb èxit la demanda i una tercera categoria encarregada del tractament de les dades per a resoldre cada una de les demandes que l'aplicació permeti. </p>
                                        <p>Els avantatges que això implica són:</p>
                                        <ul>
                                            <li>Augmentar la reusabilitat de les funcions</li>
                                            <li>Peder sofisticar la interficie de l'usuari i el control de peticions sense afectar a l'essencia de l'aplicació (tractament de dades) que seguira treballant de la mateixa manera.</li>
                                            <li>Permetre crear aplicacions identiques en diferents plataformes (WEB, local) o per diversos dispositius (PC, tablet, smartphone, etc.)</li>
                                            
                                        </ul>
                                    </div>
                                    
                                </div> 
                            </div>
                        </div>
                    </div>
                </section>
                 </section>
                <!--=========== END SUBSECTION Guia modularitzar ================-->        
          
            <!--=========== END SECTION toknow ================-->    

            <!--=========== BEGIN SECTION toDo ================-->    
            <section id="slc-toDo" class="vsections">
                <!--=========== BEGIN SUBSECTION Descripció dels exercicis ================-->    
                <section id="slc-toDo10" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Descripció general</h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p>En aquesta secció se us proposa fer 2 tasques per debatre al <span class="forumGrupReduit"></span>  , 
                                    que pretenen fer-vos reflexionar sobre els conceptes apresos en relació a les classes, biblioteques i tipus composts. Cada debat es troba en un apartat diferent. Passeu al següent per iniciar el primer debat.
                                     </p>
												         
                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Descripció dels exercicis  ================-->    
                
  					<!--=========== BEGIN SUBSECTION Debat 1 ================-->    
                <section id="slc-discussion11" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer? Classes, biblioteques i tipus composts</h2>
                                     <h3> Debat 1. La reutilització </h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                    <p> Segurament, un dels criteris que més avantatge ha suposat per el desenvolupament de programari, ha estat la reutilització del codi, perquè així s'aconsegueix codificar més ràpidament, cometent molts menys erros. És evident que per poder reutilitzar codi en diferents contextos (diferents parts d'un programa, diferents aplicacions, etc.), cal separar aquelles parts que es poden reutilitzar, de les que difícilment podran reutilitzar-se a cap altra context. </p>
                                    <p>Ara bé, cal assenyalar que crear biblioteques de funcions reutilitzables no és trivial, ja que requereix d'un esforç d'abstracció important per tal d'aïllar el que és inevitablement específic d'una aplicació, del que es pot generalitzar afegint-hi paràmetres. Si no hi parem gaire atenció, tindrem tendència a barrejar-ho tot i ens resultarà impossible trobar entre el nostre codi cap funció genèrica.</p>
                                    <p>Per exemple, és habitual, en programadors poc experimentats, barrejar en una mateixa funció la demanda de dades a l'usuari, el tractament d'aquestes i la mostra del resultat. Penseu però que generalment, les demandes de dades a l'usuari i la mostra de resultats per pantalla, són realment processos molt específics i lligats  a l'aplicació en la que s'han desenvolupat. Això els converteix realment en processos difícilment reutilitzables. Per contra, els tractaments que reben les dades solen ser processos altament reutilitzables si aconseguim parametritzar-los amb una mica d'habilitat.</p>
                                    <p>A continuació se us presenta la funció <em>trobarTemperaturaMinima</em>, la qual permet trobar el valor mínim d'un conjunt de temperatures introduïdes per l'usuari. Fixeu-vos però que la funció no compleix els requisits indicats per poder ser considerada reutilitzable, ja que només es podria fer servir en algun context que calgués trobar la temperatura mínima d'una conjunt de temperatures donades per l'usuari. És a dir exclusivament l'actual!</p>
                                    <p>Tal com està codificada la funció no serviria per trobar les temperatures mínimes emmagatzemades en el disc dur, en comptes de demanar-les a l'usuari, ni molt menys per trobar el valor mínim de quelcom que no fossin temperatures, ni permetria emmagatzemar el valor mínim en el disc dur, o enviar-lo a un servidor, en comptes de mostrar-lo per pantalla, ja que la petició de dades, el càlcul del resultat i la mostra d'aquest formen un tot indivisible.</p>
                                    <pre><code class="java linenumbers">
public void trobarTemperaturaMinima(){
float[] temperatures;
int posMin;            
System.out.println("Quantes temperatures vols omplir?");
int mida = scanner.nextInt();
temperatures = new float[mida];
            
System.out.println("Entra el valor de les temperatures");
for(int i=0; i&lt;temperatures.length; i++){
System.out.println("Temperatura " + (i+1) + ": ");
temperatures[i]=scanner.nextFloat();
     }

       posMin=0;
            for(int i=1; i&lt;temperatures.length; i++){
                if(temperatures[posMin]&gt;temperatures[i]){
                    posMin=i;
                }
            }
            System.out.println("La Temperatura mínima és: " +  temperatures[posMin]);
        }
                                     </code></pre>
                                     <p>Es demana que recodifiqueu la funció, dividint-la, de manera que agrupeu una part del codi en almenys una funció realment reutilitzable (poden ser més si ho desitgeu). 
                                     Acompanyeu la codificació amb un raonament que justifiqui la divisió realitzada i pengeu-ho al <span class="forumGrupReduit">forum grup reduit</span>.</p>
                                    <p>També es demana que reflexioneu en el fòrum, si les noves funcions substituirien totalment la funció <em>trobarTemperaturaMinima</em> de manera que caldria eliminar-la del codi, o si per contra, les noves funcions, necessitarien encara de la funció <em>trobarTemperaturaMinima</em> adaptada a la crida d'aquestes.</p>
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-discussion11" 
                                            data-selector-clue="#slc-discussion11-clue1">
                                        Pista
                                    </button>                                        
                                    <div id="slc-discussion11-clue1" class="iocClue hidden">
                                        <h2>Pista</h2>
                                        <p>Identifica la part del codi destinada a preguntar a l'usuari els valors de les temperatures, la part del codi destinada a mostrar el resultat i la part del codi destinada a cercar el valor mínim.</p>
                                        <p>Creus que hi ha diferencia entre cercar la temperatura mínima, la nota mínima, el menor temps, o el menor consum de carburant? Si no hi ha diferencia, podríem idear una un procés comú a tots ells. Quines dades necessitaria el procés? Quin seria el resultat del procés?</p>
                                    </div>                                    
                                 </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Debat 1 ================-->     

                <!--=========== BEGIN SUBSECTION Debat 2 ================-->    
                <section id="slc-toDo30" class=" section">
                    <div class="container">
                        <div class="row">
                            <div class="col-lg-12">
                                <div class= "headSlide">
                                     <h2 >Què cal fer - Classes, biblioteques i tipus composts</h2>
                                     <h3 >Debat 2- Tipus composts </h3>
                                 </div>
                            </div>
                        </div>
                        <div class="row">
                            <div class="col-lg-12">
                                <div class=bodySlide>
                                <p>Imaginem una aplicació per jugar al senzill joc de les dames.  
                                Recordeu que es juga amb un tauler de 10x10 caselles, que juguen 2 jugadors i que cada jugador disposa de 12 fitxes de diferent color que cal disposar a certes caselles del tauler. 
                                Imaginem que l'aplicació vol identificar el nom dels dos jugadors i també el nombre de partides guanyades. </p> 	
										  <p>Si decidim representar el tauler com una matriu de valors numèrics, en el que el valor zero representi les caselles buides, el valor u, 
										  representi les fitxes blanques i el valor dos, les negres; podríem crear la següent especificació per donar resposta a les necessitats de l'aplicació:</p>
										 <div class="iocexample">                                  
                                    <pre><code class="java">
public class DadesJocDames {    
    int CASELLA_BUIDA = 0;
    int FITXA_BLANCA = 1;
    int FITXA_NEGRA = 2;

    int[][] tauler = new int[10][10];
    int torn;
    Jugador jugadorBlanques;
    Jugador jugadorNegres;
}

public class Jugador {    
    String nom;
    int partidesGuanyades;
}
                                    </code></pre>
                                    </div>
                                    <p>La classe DadesJocDames contindria les dades que permeten identificar un moment determinat de la  partida que s'estigui jugant (la posició de les fitxes, el torn del jugador que li toqui tirar i les dades especifiques de cada un d'aquest agrupades com estructura Jugador). 
                                    Serà la classe Jugador, l'encarregada  de mantenir les dades específiques referents a un jugador (el nom i les partides guanyades).</p>
                                                                        <p>
												Cal deixar clar, però que l'especificació només indica la composició de les dades. 
												Per poder-es fer servir, caldrà declarar variables indicant el nom de l'estructura a usar, de forma semblant com s'indiquen el tipus de dades.                                    
                                    </p>

                                    <div class="frameBox">
                                        <h4>Questions pel debat en el <span class="forumGrupReduit"></span></h4>
                                         <ol>
                                            <li>Creieu que l'estructura de dades DadesJocDames respon als requisits de l'aplicació?</li>
                                            <li>Com inicialitzaries les dades de l'estructura?</li>
                                        </ol>
                                    </div>
                        <p>Per accedir als elements d'una estructura de dades, després del nom de la variable concatenarem un punt seguit del nom de l'element on desitgem accedir o manipular.  </p>
                                <div class="iocexample">
                                         <pre><code class="java">      
 public class Aplicacio {
    DadesJocDames joc;

    public static void main(String[] args){
        Aplicacio aplicacio = new Aplicacio();
        aplicacio.inici();
    }

    void inici(){
        joc = new DadesJocDames();
        joc.jugadorBlanques = new Jugador();
	     joc.jugadorNegres = new Jugador();

        //Exemples d'assignació i lectura dels valors        
        joc.jugadorBlanques.nom = demanarNomJugador(joc.FITXA_BLANCA);
        joc.jugadorNegres.nom = demanarNomJugador(joc.FITXA_NEGRA);
        ...
    }
    
    ...
}
        </code></pre>
        <p>Aquest exemple que acabem de veure, només funcionarà si la classe Aplicació es troba en el mateix paquet que les classes  DadesJocDames i Jugador. 
			</p>
			<div class="frameBox">
                                        <h4>Questions pel debat en el <span class="forumGrupReduit"></span></h4>
                                         <ol>
                                            <li>Si situem la classe Aplicació en un paquet diferent, encara que iniciem la variable joc, no podrem accedir a cap dels seus elements. Què haurem de fer en aquest cas?</li>
                                        </ol>
                                    </div>
                                    
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg btn-toggle toggle-off" 
                                            data-toggle="button"
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-toDo30" 
                                            data-selector-clue="#slc-toDo30-clue1">
                                        Pista
                                    </button>                                        
                                    <div id="slc-toDo30-clue1" class="iocClue hidden">
                                        <h2>Pista</h2>
                                         <p>En JAVA les variables que representen Estructures de dades es declaren:</p>
                                   
                                    <div class="iocexample">
                                         <pre><code class="java">
                                          NomEstructuraDeDades identificadorVariable;
                                         </code></pre>
                                    </div>
                                    
                                    <p>Abans de fer servir una variable d'algun tipus d'estructura de dades cal haver-la inicialitzat. 
                                    Si no es fa, a l'intentar usar-la obtindrem un error que aturarà l'execució. 
                                   
                                    És possible inicialitzar les variables des de la pròpia declaració: </p>
                                    <div class="iocexample">
                                         <pre><code class="java">
                                          NomEstructuraDeDades identificadorVariable = new NomEstructuraDeDades ();
} 
                                         </code></pre>
                                    </div>                       
                                          
                                        
                                    </div>
                                    <!-- Button trigger pannel -->
                                    <button type="button" class="btn btn-primary btn-lg toggle-off btn-3d" 
                                            data-parent-selector="#leftColumnPanel"
                                            data-display-on-set-slide="slc-toDo30" 
                                            data-selector-solution="#slc-toDo30-solution">
                                       Solució
                                    </button>                                        
                                    <div id="slc-toDo30-solution" class="iocSolution hidden">
                                        <h2>Solució </h2>
                                      <div class="iocexample">
                                         <pre><code class="java">
public class DadesJocDames {    
    int CASELLA_BUIDA = 0;
    int FITXA_BLANCA = 1;
    int FITXA_NEGRA = 2;

    int[][] tauler = new int[10][10];
    int torn;
    Jugador jugadorBlanques = new Jugador();
    Jugador jugadorNegres = new Jugador();
}
												</code></pre>
												<p>O bé: </p>
												<div class="iocexample">
                                         <pre><code class="java">
		DadesJocDames joc;
        
        ...
	
		public static void main(String[] args){
			//Abans d'inicialitzar el elemnts jugadorBlanques i jugadorNegres cal incialitzar joc
			...
			//inicialització en diferit	
			joc = new DadesJocDames();
			//Ja es possible inicialitzar els elements interns
			...
			joc.jugadorBlanques = new Jugador();
			joc.jugadorNegres = new Jugador();
			// a partir d'aquí ja queda tot inicialitzat.
			...
		}
		...
												</code></pre>
                                    </div>
                                   

                                </div>
                            </div>
                        </div>
                    </div>
                </section>
                <!--=========== END SUBSECTION Exercici 2 ================-->   
            </section>
            <!--=========== END SECTION toDo ================-->    

            <!--=========== BEGIN SECTION toDelivery ================-->    
            <section id="slc-toDelivery">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Lliurament - Classes, biblioteques i tipus composts</h2>
                             </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-12">
                            <div class=bodySlide>
                                <p>En aquesta A501 se us demana que participeu als debats proposats al <span class="forumGrupReduit"></span>. Es recomana acabar i lliurar aquesta activitat abans de la data recomanada: <strong class='dataRecomanada'></strong> i en tot cas mai després de la data límit: <strong class="dataLimit"></strong>.</p>
                                <p>És molt important pel vostre aprenentatge que participeu en els debats proposats. També és important pel professor doncs pot avaluar l'evolució del vostre l'aprenentatge així com la utilitat l'activitat en el conjunt del procés i proposar canvis futurs si calguessin. </p>
                            </  div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toDelivery ================-->    
            
            <!--=========== BEGIN SECTION toContinue ================-->    
            <section id="slc-toContinue">
                <div class="container">
                    <div class="row">
                        <div class="col-lg-12">
                            <div class= "headSlide">
                                 <h2 >Com continuar</h2>
                             </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-lg-12">
                            <div class=bodySlide>
                                <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en cosntrucció"> Text provisional. Estem treballant per millorar</div>                               
                                <p>Passeu a la següent <span class="toNextActivity"></span></p>
                            </div>
                        </div>
                    </div>
                </div>
            </section>
            <!--=========== END SECTION toContinue ================-->    
        </div>
    </div>
    <!--=========== END MAIN SLIDER SECTION ================-->    

    <!--=========== BEGIN META-INFO PANELS ================-->    
    <div id="sidepanel-wrapper" class="left-position after-top-menu">
        <a id="panel-close" href="#" class="panel-close btn btn-light pull-right toggle"><i class="glyphicon glyphicon-remove-circle"></i></a>
        <div id="goals_info" class="bodySlide hidden"> 
            <h2>Objectius d'aprenentatge de l'activitat</h2>
            <ul>
            <li>	1. Descompodre un programa en funcions i classificar les funcions en mòduls (classes) d'acord a criteris ben definits i útils. Entre d'altres, són criteris bàsics mòduls d'entrada i sortida, mòduls de control, i mòduls de tractament de dades.</li>
				<li>	2. Implementar biblioteques reutilitzables i específiques d'una aplicació.</li>
				<li>	3. Usar estructures de dades senzilles per agrupar les dades de l'aplicació en pocs accessos.</li>
				<li>	4. Identificar quan cal instanciar les estructures de dades i compassar-les a les diverses funcions. </li>
				<li>	5. Crear instancies de classes repositori de codi abans d'executar els seus mètodes escollint si es creen a nivell local o global. En qualsevol cas cal  vigilar no entrar en inicialitzacions recursisves que malbaratin o fins i tot exhaureixin la memòria.</li>
				<li>	6. Documentar les diferents classes usant la sintaxi javadoc.</li>
				<li>	7. Usar classes internes del llenguatge JAVA: String, Arrays, Math i Random.</li>
				<li>	8. Planificar planificar les pantalles, controls i funcions d'alt nivell que estructuren un programa.</li>
				<li>	9. Fer una transferència correcte de les dades mitjançant paràmetres durant l'execució. </li>
				<li>	10. Descompondre un programa en funcions i classificar les funcions en mòduls (classes) d'acord a criteris ben definits i útils. Entre d'altres, són criteris bàsics mòduls d'entrada i sortida, mòduls de control, i mòduls de tractament de dades.</li>
            </ul>
            <h2>Resultats d'aprenentatge del mòdul treballats en aquesta activitat</h2>
            <ul>
            	 <li>Prova, depura, comenta i documenta els programes.</li>
                <li>Defineix el concepte de llibreries i la seva utilitat.</li>
                <li>Utilitza llibreries en l’elaboració de programes</li>
            </ul>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                                           
            <p>Aquí s'afegiran els resultats d'aprenentatge del mòdul que es treballen en aquesta activitat</p>
        </div>
        <div id="more_reinforcement" class="hidden"> 
            <h2>Més activitats i idees per reforçar l'aprenentatge</h2>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                               
            <p>Aquí s'afegiran exercicis, activitats, lectures o referencies externes per tal que l'estudiant, pugui reforçar el conceptes estudiats </p>
        </div>
        <div id="more_info" class="hidden"> 
            <h2>Informació sobre funcions  per ampliar</h2>
            <div class="marquee centerSlide iocwarning"> <img src="images/enConstruccio.png" width="35" height="35" alt="en construcció"> Text provisional. Estem treballant per millorar</div>                               
            <p>Aquí s'afegiran lectures, activitats referències externes o bibliografia on l'estudiant, pugui ampliar l'aprenentatge si ho desitja</p>
        </div>
    </div>
    <!--=========== END META-INFO PANELS ================-->    
    
    <!--=========== BEGIN EMPTY PANEL ================-->    
    <div id="emptypanel-wrapper" class="right-position after-top-menu">
    </div>
    <!--=========== END EMPTY PANEL ================-->    
    
    <!--=========== BEGIN EMPTY MODAL WINDOW ================-->    
    <div id="modalWindow" class="iocModal hidden">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-selector-to-set-class="#modalWindow" data-class-to-set-class="iocModal hidden" aria-label="Close"><span aria-hidden="true">×</span></button>
            <h4 class="modal-title">Modal title</h4>
          </div>
          <div class="modal-body">
            
          </div>
          <div class="modal-footer">
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div><!-- /.modal -->
    <!--=========== END EMPTY MODAL WINDOW ================-->    

    <!--=========== BEGIN EMPTY LEFT COLUMN PANEL ================-->    
    <div id="leftColumnPanel" class="left-position column-panel after-top-menu">
    </div>
    <!--=========== END EMPTY LEFT COLUMN PANEL ================-->    

    <!--=========== BEGIN EMPTY HIDDEN PANEL ================-->    
    <div id="hiddenContent" class="hidden">
    </div>
    <!--=========== END EMPTY HIDDEN PANEL ================-->    

    <!--=========== BEGIN SCRIPTS ================-->    
    <!-- jQuery -->
    <script src="js/jquery.js"></script>
    <script src="js/jquery.easing.min.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="js/bootstrap.min.js"></script>

    <!-- highlight.js plugin -->
    <script src="js/highlight.pack.js"></script>

    <!-- jssor.js plugin -->
    <script src="js/jssor.js"></script>
    <script src="js/jssor.slider.js"></script>
    
    <!-- to run jssor here-->
    <script src="js/jssorActivities.js"></script>

    <!-- slides functionality-->
    <script src="js/scrolling-slides.js"></script>

    <!-- specific functionality for IOC activities-->
    <script src="js/m03b2Activities.js"></script>

    <!-- specific functionality for this activ¡ty-->
    <script>
         $(document).ready(function(){
            var activityManager = new ActivityManager();
            
            activityManager.init("data/toReplace.json", "A501");
            var iocSlider = new IocSlider();
            activityManager.updateDisplayButtons(iocSlider);
        });

        /*    
        iocSlider = new IocSlider();
        iocSlider.addJssorSlider("slider1_container");

        $("[data-display-on-set-slide]").each(function(){
            var slide;
            var self = this;
            var slideId = this.dataset.displayOnSetSlide; 
            iocSlider.watch("onSetCurrentSlide", function(e){
                var slide;
                var oldSlide =e.oldValues.vindx!=-1
                                    ?e.oldValues.vslides[e.oldValues.vindx]
                                    :e.oldValues.hslides[e.oldValues.hindx];
                if($(oldSlide).attr("id")===slideId){
                   $(self).hide();
                   if($(self).hasClass("active")){
                        $(self).click();
                   }
                }
                slide = this.hasVerticalSlides()
                                    ?this.vslides[this.vindx]
                                    :this.hslides[this.hindx];
                if($(slide).attr("id")===slideId){
                   $(self).show();
                }
            });
    
            slide = iocSlider.hasVerticalSlides()
                                ?iocSlider.vslides[iocSlider.vindx]
                                :iocSlider.hslides[iocSlider.hindx];
            if($(slide).attr("id")===slideId){
               $(this).show();
            }
        });

        hljs.addLineNumbers();
        hljs.initHighlightingOnLoad();
        
        $(document).ready(function(){
            toReplaceOnLoad("data/toReplace.json", "A501");
        });
        */
    </script>

</body>

</html>


